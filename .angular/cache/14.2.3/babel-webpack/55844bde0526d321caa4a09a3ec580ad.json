{"ast":null,"code":"import _defineProperty from \"C:/Users/nsuwanw/Desktop/smartlocker-sp/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectWithoutProperties from \"C:/Users/nsuwanw/Desktop/smartlocker-sp/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _toConsumableArray from \"C:/Users/nsuwanw/Desktop/smartlocker-sp/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _inherits from \"C:/Users/nsuwanw/Desktop/smartlocker-sp/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/nsuwanw/Desktop/smartlocker-sp/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _objectSpread from \"C:/Users/nsuwanw/Desktop/smartlocker-sp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"C:/Users/nsuwanw/Desktop/smartlocker-sp/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/nsuwanw/Desktop/smartlocker-sp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/nsuwanw/Desktop/smartlocker-sp/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/nsuwanw/Desktop/smartlocker-sp/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar _excluded = [\"openBrowser\", \"successTemplate\", \"errorTemplate\"];\nimport { Constants as Constants$1, ProtocolMode, AzureCloudInstance, LogLevel, StringUtils, AccountEntity, CacheManager, IdTokenEntity, AccessTokenEntity, RefreshTokenEntity, AppMetadataEntity, ServerTelemetryEntity, AuthorityMetadataEntity, ThrottlingEntity, TokenCacheContext, AuthError, Logger, ResponseMode, AuthenticationScheme, AuthorizationCodeClient, RefreshTokenClient, SilentFlowClient, UsernamePasswordClient, ClientAuthError, OIDC_DEFAULT_SCOPES, ServerTelemetryManager, Authority, AuthorityFactory, UrlString, DeviceCodeClient, ServerError, CodeChallengeMethodValues, TimeUtils, ClientCredentialClient, OnBehalfOfClient } from '@azure/msal-common';\nexport { AuthError, AuthErrorMessage, AzureCloudInstance, ClientAuthError, ClientAuthErrorMessage, ClientConfigurationError, ClientConfigurationErrorMessage, InteractionRequiredAuthError, InteractionRequiredAuthErrorMessage, LogLevel, Logger, PromptValue, ProtocolMode, ResponseMode, ServerError, TokenCacheContext } from '@azure/msal-common';\nimport http, { createServer } from 'http';\nimport https from 'https';\nimport { v4 } from 'uuid';\nimport crypto from 'crypto';\nimport { sign } from 'jsonwebtoken';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * http methods\r\n */\n\nvar HttpMethod = /*#__PURE__*/(function () {\n  (function (HttpMethod) {\n    HttpMethod[\"GET\"] = \"get\";\n    HttpMethod[\"POST\"] = \"post\";\n  })(HttpMethod || (HttpMethod = {}));\n\n  return HttpMethod;\n})();\nvar HttpStatus = /*#__PURE__*/(function () {\n  (function (HttpStatus) {\n    HttpStatus[HttpStatus[\"OK\"] = 200] = \"OK\";\n    HttpStatus[HttpStatus[\"REDIRECT\"] = 302] = \"REDIRECT\";\n  })(HttpStatus || (HttpStatus = {}));\n\n  return HttpStatus;\n})();\n\n/**\r\n * Constants used for region discovery\r\n */\nvar REGION_ENVIRONMENT_VARIABLE = \"REGION_NAME\";\n/**\r\n * Constant used for PKCE\r\n */\n\nvar RANDOM_OCTET_SIZE = 32;\n/**\r\n * Constants used in PKCE\r\n */\n\nvar Hash = {\n  SHA256: \"sha256\"\n};\n/**\r\n * Constants for encoding schemes\r\n */\n\nvar CharSet = {\n  CV_CHARSET: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~\"\n};\n/**\r\n * Constants\r\n */\n\nvar Constants = {\n  MSAL_SKU: \"msal.js.node\",\n  JWT_BEARER_ASSERTION_TYPE: \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",\n  AUTHORIZATION_PENDING: \"authorization_pending\",\n  HTTP_PROTOCOL: \"http://\",\n  LOCALHOST: \"localhost\"\n};\n/**\r\n * API Codes for Telemetry purposes.\r\n * Before adding a new code you must claim it in the MSAL Telemetry tracker as these number spaces are shared across all MSALs\r\n * 0-99 Silent Flow\r\n * 600-699 Device Code Flow\r\n * 800-899 Auth Code Flow\r\n */\n\nvar ApiId = /*#__PURE__*/(function () {\n  (function (ApiId) {\n    ApiId[ApiId[\"acquireTokenSilent\"] = 62] = \"acquireTokenSilent\";\n    ApiId[ApiId[\"acquireTokenByUsernamePassword\"] = 371] = \"acquireTokenByUsernamePassword\";\n    ApiId[ApiId[\"acquireTokenByDeviceCode\"] = 671] = \"acquireTokenByDeviceCode\";\n    ApiId[ApiId[\"acquireTokenByClientCredential\"] = 771] = \"acquireTokenByClientCredential\";\n    ApiId[ApiId[\"acquireTokenByCode\"] = 871] = \"acquireTokenByCode\";\n    ApiId[ApiId[\"acquireTokenByRefreshToken\"] = 872] = \"acquireTokenByRefreshToken\";\n  })(ApiId || (ApiId = {}));\n\n  return ApiId;\n})();\n\n/**\r\n * JWT  constants\r\n */\nvar JwtConstants = {\n  ALGORITHM: \"alg\",\n  RSA_256: \"RS256\",\n  X5T: \"x5t\",\n  X5C: \"x5c\",\n  AUDIENCE: \"aud\",\n  EXPIRATION_TIME: \"exp\",\n  ISSUER: \"iss\",\n  SUBJECT: \"sub\",\n  NOT_BEFORE: \"nbf\",\n  JWT_ID: \"jti\"\n};\nvar LOOPBACK_SERVER_CONSTANTS = {\n  INTERVAL_MS: 100,\n  TIMEOUT_MS: 5000\n};\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * This class implements the API for network requests.\r\n */\n\nvar HttpClient = /*#__PURE__*/function () {\n  function HttpClient() {\n    _classCallCheck(this, HttpClient);\n  }\n\n  _createClass(HttpClient, [{\n    key: \"sendGetRequestAsync\",\n    value:\n    /**\r\n     * Http Get request\r\n     * @param url\r\n     * @param options\r\n     */\n    function () {\n      var _sendGetRequestAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url, options) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(options != null && options.proxyUrl)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", networkRequestViaProxy(url, HttpMethod.GET, options));\n\n              case 4:\n                return _context.abrupt(\"return\", networkRequestViaHttps(url, HttpMethod.GET, options));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function sendGetRequestAsync(_x, _x2) {\n        return _sendGetRequestAsync.apply(this, arguments);\n      }\n\n      return sendGetRequestAsync;\n    }()\n    /**\r\n     * Http Post request\r\n     * @param url\r\n     * @param options\r\n     */\n\n  }, {\n    key: \"sendPostRequestAsync\",\n    value: function () {\n      var _sendPostRequestAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(url, options, cancellationToken) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(options != null && options.proxyUrl)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", networkRequestViaProxy(url, HttpMethod.POST, options, cancellationToken));\n\n              case 4:\n                return _context2.abrupt(\"return\", networkRequestViaHttps(url, HttpMethod.POST, options, cancellationToken));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function sendPostRequestAsync(_x3, _x4, _x5) {\n        return _sendPostRequestAsync.apply(this, arguments);\n      }\n\n      return sendPostRequestAsync;\n    }()\n  }]);\n\n  return HttpClient;\n}();\n\nvar networkRequestViaProxy = function networkRequestViaProxy(url, httpMethod, options, timeout) {\n  var headers = (options == null ? void 0 : options.headers) || {};\n  var proxyUrl = new URL((options == null ? void 0 : options.proxyUrl) || \"\");\n  var destinationUrl = new URL(url); // \"method: connect\" must be used to establish a connection to the proxy\n\n  var tunnelRequestOptions = {\n    host: proxyUrl.hostname,\n    port: proxyUrl.port,\n    method: \"CONNECT\",\n    path: destinationUrl.hostname,\n    headers: headers\n  };\n\n  if (timeout) {\n    tunnelRequestOptions.timeout = timeout;\n  } // compose a request string for the socket\n\n\n  var postRequestStringContent = \"\";\n\n  if (httpMethod === HttpMethod.POST) {\n    var body = (options == null ? void 0 : options.body) || \"\";\n    postRequestStringContent = \"Content-Type: application/x-www-form-urlencoded\\r\\n\" + \"Content-Length: \".concat(body.length, \"\\r\\n\") + \"\\r\\n\".concat(body);\n  }\n\n  var outgoingRequestString = \"\".concat(httpMethod.toUpperCase(), \" \").concat(destinationUrl.href, \" HTTP/1.1\\r\\n\") + \"Host: \".concat(destinationUrl.host, \"\\r\\n\") + \"Connection: close\\r\\n\" + postRequestStringContent + \"\\r\\n\";\n  return new Promise(function (resolve, reject) {\n    var request = http.request(tunnelRequestOptions);\n\n    if (tunnelRequestOptions.timeout) {\n      request.on(\"timeout\", function () {\n        request.destroy();\n        reject(new Error(\"Request time out\"));\n      });\n    }\n\n    request.end(); // establish connection to the proxy\n\n    request.on(\"connect\", function (response, socket) {\n      var statusCode = (response == null ? void 0 : response.statusCode) || 500;\n\n      if (statusCode < 200 || statusCode > 299) {\n        request.destroy();\n        socket.destroy();\n        reject(new Error(\"HTTP status code \".concat(statusCode)));\n      }\n\n      if (tunnelRequestOptions.timeout) {\n        socket.setTimeout(tunnelRequestOptions.timeout);\n        socket.on(\"timeout\", function () {\n          request.destroy();\n          socket.destroy();\n          reject(new Error(\"Request time out\"));\n        });\n      } // make a request over an HTTP tunnel\n\n\n      socket.write(outgoingRequestString);\n      var data = [];\n      socket.on(\"data\", function (chunk) {\n        data.push(chunk);\n      });\n      socket.on(\"end\", function () {\n        // combine all received buffer streams into one buffer, and then into a string\n        var dataString = Buffer.concat([].concat(data)).toString(); // separate each line into it's own entry in an arry\n\n        var dataStringArray = dataString.split(\"\\r\\n\"); // the first entry will contain the statusCode\n\n        var statusCode = parseInt(dataStringArray[0].split(\" \")[1]); // the last entry will contain the body\n\n        var body = dataStringArray[dataStringArray.length - 1]; // everything in between the first and last entries are the headers\n\n        var headersArray = dataStringArray.slice(1, dataStringArray.length - 2); // build an object out of all the headers\n\n        var entries = new Map();\n        headersArray.forEach(function (header) {\n          /**\r\n           * the header might look like \"Content-Length: 1531\", but that is just a string\r\n           * it needs to be converted to a key/value pair\r\n           * split the string at the first instance of \":\"\r\n           * there may be more than one \":\" if the value of the header is supposed to be a JSON object\r\n           */\n          var headerKeyValue = header.split(new RegExp(/:\\s([\\s\\S]*)/));\n          var headerKey = headerKeyValue[0];\n          var headerValue = headerKeyValue[1]; // check if the value of the header is supposed to be a JSON object\n\n          try {\n            var object = JSON.parse(headerValue); // if it is, then convert it from a string to a JSON object\n\n            if (object && typeof object === \"object\") {\n              headerValue = object;\n            }\n          } catch (e) {// otherwise, leave it as a string\n          }\n\n          entries.set(headerKey, headerValue);\n        });\n        var headers = Object.fromEntries(entries);\n        var networkResponse = {\n          headers: headers,\n          body: JSON.parse(body),\n          status: statusCode\n        };\n\n        if ((statusCode < 200 || statusCode > 299) && // do not destroy the request for the device code flow\n        networkResponse.body[\"error\"] !== Constants.AUTHORIZATION_PENDING) {\n          request.destroy();\n          socket.destroy();\n          reject(new Error(\"HTTP status code \".concat(statusCode)));\n        }\n\n        resolve(networkResponse);\n      });\n      socket.on(\"error\", function (chunk) {\n        request.destroy();\n        socket.destroy();\n        reject(new Error(chunk.toString()));\n      });\n    });\n    request.on(\"error\", function (chunk) {\n      request.destroy();\n      reject(new Error(chunk.toString()));\n    });\n  });\n};\n\nvar networkRequestViaHttps = function networkRequestViaHttps(url, httpMethod, options, timeout) {\n  var isPostRequest = httpMethod === HttpMethod.POST;\n  var body = (options == null ? void 0 : options.body) || \"\";\n  var emptyHeaders = {};\n  var customOptions = {\n    method: httpMethod,\n    headers: (options == null ? void 0 : options.headers) || emptyHeaders\n  };\n\n  if (timeout) {\n    customOptions.timeout = timeout;\n  }\n\n  if (isPostRequest) {\n    // needed for post request to work\n    customOptions.headers = _objectSpread(_objectSpread({}, customOptions.headers), {}, {\n      \"Content-Length\": body.length\n    });\n  }\n\n  return new Promise(function (resolve, reject) {\n    var request = https.request(url, customOptions);\n\n    if (timeout) {\n      request.on(\"timeout\", function () {\n        request.destroy();\n        reject(new Error(\"Request time out\"));\n      });\n    }\n\n    if (isPostRequest) {\n      request.write(body);\n    }\n\n    request.end();\n    request.on(\"response\", function (response) {\n      var headers = response.headers;\n      var statusCode = response.statusCode;\n      var data = [];\n      response.on(\"data\", function (chunk) {\n        data.push(chunk);\n      });\n      response.on(\"end\", function () {\n        // combine all received buffer streams into one buffer, and then into a string\n        var body = Buffer.concat([].concat(data)).toString();\n        var networkResponse = {\n          headers: headers,\n          body: JSON.parse(body),\n          status: statusCode\n        };\n\n        if ((statusCode < 200 || statusCode > 299) && // do not destroy the request for the device code flow\n        networkResponse.body[\"error\"] !== Constants.AUTHORIZATION_PENDING) {\n          request.destroy();\n          reject(new Error(\"HTTP status code \".concat(statusCode)));\n        }\n\n        resolve(networkResponse);\n      });\n    });\n    request.on(\"error\", function (chunk) {\n      request.destroy();\n      reject(new Error(chunk.toString()));\n    });\n  });\n};\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n\nvar NetworkUtils = /*#__PURE__*/function () {\n  function NetworkUtils() {\n    _classCallCheck(this, NetworkUtils);\n  }\n\n  _createClass(NetworkUtils, null, [{\n    key: \"getNetworkClient\",\n    value:\n    /**\r\n     * Returns best compatible network client object.\r\n     */\n    function getNetworkClient() {\n      return new HttpClient();\n    }\n  }]);\n\n  return NetworkUtils;\n}();\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n\nvar DEFAULT_AUTH_OPTIONS = {\n  clientId: Constants$1.EMPTY_STRING,\n  authority: Constants$1.DEFAULT_AUTHORITY,\n  clientSecret: Constants$1.EMPTY_STRING,\n  clientAssertion: Constants$1.EMPTY_STRING,\n  clientCertificate: {\n    thumbprint: Constants$1.EMPTY_STRING,\n    privateKey: Constants$1.EMPTY_STRING,\n    x5c: Constants$1.EMPTY_STRING\n  },\n  knownAuthorities: [],\n  cloudDiscoveryMetadata: Constants$1.EMPTY_STRING,\n  authorityMetadata: Constants$1.EMPTY_STRING,\n  clientCapabilities: [],\n  protocolMode: ProtocolMode.AAD,\n  azureCloudOptions: {\n    azureCloudInstance: AzureCloudInstance.None,\n    tenant: Constants$1.EMPTY_STRING\n  },\n  skipAuthorityMetadataCache: false\n};\nvar DEFAULT_CACHE_OPTIONS = {};\nvar DEFAULT_LOGGER_OPTIONS = {\n  loggerCallback: function loggerCallback() {// allow users to not set logger call back\n  },\n  piiLoggingEnabled: false,\n  logLevel: LogLevel.Info\n};\nvar DEFAULT_SYSTEM_OPTIONS = {\n  loggerOptions: DEFAULT_LOGGER_OPTIONS,\n  networkClient: /*#__PURE__*/NetworkUtils.getNetworkClient(),\n  proxyUrl: Constants$1.EMPTY_STRING\n};\nvar DEFAULT_TELEMETRY_OPTIONS = {\n  application: {\n    appName: Constants$1.EMPTY_STRING,\n    appVersion: Constants$1.EMPTY_STRING\n  }\n};\n/**\r\n * Sets the default options when not explicitly configured from app developer\r\n *\r\n * @param auth - Authentication options\r\n * @param cache - Cache options\r\n * @param system - System options\r\n * @param telemetry - Telemetry options\r\n *\r\n * @returns Configuration\r\n * @public\r\n */\n\nfunction buildAppConfiguration(_ref) {\n  var auth = _ref.auth,\n      cache = _ref.cache,\n      system = _ref.system,\n      telemetry = _ref.telemetry;\n  return {\n    auth: _objectSpread(_objectSpread({}, DEFAULT_AUTH_OPTIONS), auth),\n    cache: _objectSpread(_objectSpread({}, DEFAULT_CACHE_OPTIONS), cache),\n    system: _objectSpread(_objectSpread({}, DEFAULT_SYSTEM_OPTIONS), system),\n    telemetry: _objectSpread(_objectSpread({}, DEFAULT_TELEMETRY_OPTIONS), telemetry)\n  };\n}\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n\nvar GuidGenerator = /*#__PURE__*/function () {\n  function GuidGenerator() {\n    _classCallCheck(this, GuidGenerator);\n  }\n\n  _createClass(GuidGenerator, [{\n    key: \"generateGuid\",\n    value:\n    /**\r\n     *\r\n     * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.\r\n     * uuidv4 generates guids from cryprtographically-string random\r\n     */\n    function generateGuid() {\n      return v4();\n    }\n    /**\r\n     * verifies if a string is  GUID\r\n     * @param guid\r\n     */\n\n  }, {\n    key: \"isGuid\",\n    value: function isGuid(guid) {\n      var regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n      return regexGuid.test(guid);\n    }\n  }]);\n\n  return GuidGenerator;\n}();\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n\nvar EncodingUtils = /*#__PURE__*/function () {\n  function EncodingUtils() {\n    _classCallCheck(this, EncodingUtils);\n  }\n\n  _createClass(EncodingUtils, null, [{\n    key: \"base64Encode\",\n    value:\n    /**\r\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\r\n     * 'base64': Base64 encoding.\r\n     *\r\n     * @param str text\r\n     */\n    function base64Encode(str, encoding) {\n      return Buffer.from(str, encoding).toString(\"base64\");\n    }\n    /**\r\n     * encode a URL\r\n     * @param str\r\n     */\n\n  }, {\n    key: \"base64EncodeUrl\",\n    value: function base64EncodeUrl(str, encoding) {\n      return EncodingUtils.base64Encode(str, encoding).replace(/=/g, Constants$1.EMPTY_STRING).replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    }\n    /**\r\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\r\n     * 'base64': Base64 encoding.\r\n     *\r\n     * @param base64Str Base64 encoded text\r\n     */\n\n  }, {\n    key: \"base64Decode\",\n    value: function base64Decode(base64Str) {\n      return Buffer.from(base64Str, \"base64\").toString(\"utf8\");\n    }\n    /**\r\n     * @param base64Str Base64 encoded Url\r\n     */\n\n  }, {\n    key: \"base64DecodeUrl\",\n    value: function base64DecodeUrl(base64Str) {\n      var str = base64Str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\n      while (str.length % 4) {\n        str += \"=\";\n      }\n\n      return EncodingUtils.base64Decode(str);\n    }\n  }]);\n\n  return EncodingUtils;\n}();\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n\nvar HashUtils = /*#__PURE__*/function () {\n  function HashUtils() {\n    _classCallCheck(this, HashUtils);\n  }\n\n  _createClass(HashUtils, [{\n    key: \"sha256\",\n    value:\n    /**\r\n     * generate 'SHA256' hash\r\n     * @param buffer\r\n     */\n    function sha256(buffer) {\n      return crypto.createHash(Hash.SHA256).update(buffer).digest();\n    }\n  }]);\n\n  return HashUtils;\n}();\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * https://tools.ietf.org/html/rfc7636#page-8\r\n */\n\n\nvar PkceGenerator = /*#__PURE__*/function () {\n  function PkceGenerator() {\n    _classCallCheck(this, PkceGenerator);\n\n    this.hashUtils = new HashUtils();\n  }\n  /**\r\n   * generates the codeVerfier and the challenge from the codeVerfier\r\n   * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2\r\n   */\n\n\n  _createClass(PkceGenerator, [{\n    key: \"generatePkceCodes\",\n    value: function () {\n      var _generatePkceCodes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var verifier, challenge;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                verifier = this.generateCodeVerifier();\n                challenge = this.generateCodeChallengeFromVerifier(verifier);\n                return _context3.abrupt(\"return\", {\n                  verifier: verifier,\n                  challenge: challenge\n                });\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function generatePkceCodes() {\n        return _generatePkceCodes.apply(this, arguments);\n      }\n\n      return generatePkceCodes;\n    }()\n    /**\r\n     * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1\r\n     */\n\n  }, {\n    key: \"generateCodeVerifier\",\n    value: function generateCodeVerifier() {\n      var charArr = [];\n      var maxNumber = 256 - 256 % CharSet.CV_CHARSET.length;\n\n      while (charArr.length <= RANDOM_OCTET_SIZE) {\n        var byte = crypto.randomBytes(1)[0];\n\n        if (byte >= maxNumber) {\n          /*\r\n           * Ignore this number to maintain randomness.\r\n           * Including it would result in an unequal distribution of characters after doing the modulo\r\n           */\n          continue;\n        }\n\n        var index = byte % CharSet.CV_CHARSET.length;\n        charArr.push(CharSet.CV_CHARSET[index]);\n      }\n\n      var verifier = charArr.join(Constants$1.EMPTY_STRING);\n      return EncodingUtils.base64EncodeUrl(verifier);\n    }\n    /**\r\n     * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2\r\n     * @param codeVerifier\r\n     */\n\n  }, {\n    key: \"generateCodeChallengeFromVerifier\",\n    value: function generateCodeChallengeFromVerifier(codeVerifier) {\n      return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(codeVerifier).toString(\"base64\"), \"base64\");\n    }\n  }]);\n\n  return PkceGenerator;\n}();\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * This class implements MSAL node's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and\r\n * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).\r\n * @public\r\n */\n\n\nvar CryptoProvider = /*#__PURE__*/function () {\n  function CryptoProvider() {\n    _classCallCheck(this, CryptoProvider);\n\n    // Browser crypto needs to be validated first before any other classes can be set.\n    this.pkceGenerator = new PkceGenerator();\n    this.guidGenerator = new GuidGenerator();\n    this.hashUtils = new HashUtils();\n  }\n  /**\r\n   * Creates a new random GUID - used to populate state and nonce.\r\n   * @returns string (GUID)\r\n   */\n\n\n  _createClass(CryptoProvider, [{\n    key: \"createNewGuid\",\n    value: function createNewGuid() {\n      return this.guidGenerator.generateGuid();\n    }\n    /**\r\n     * Encodes input string to base64.\r\n     * @param input - string to be encoded\r\n     */\n\n  }, {\n    key: \"base64Encode\",\n    value: function base64Encode(input) {\n      return EncodingUtils.base64Encode(input);\n    }\n    /**\r\n     * Decodes input string from base64.\r\n     * @param input - string to be decoded\r\n     */\n\n  }, {\n    key: \"base64Decode\",\n    value: function base64Decode(input) {\n      return EncodingUtils.base64Decode(input);\n    }\n    /**\r\n     * Generates PKCE codes used in Authorization Code Flow.\r\n     */\n\n  }, {\n    key: \"generatePkceCodes\",\n    value: function generatePkceCodes() {\n      return this.pkceGenerator.generatePkceCodes();\n    }\n    /**\r\n     * Generates a keypair, stores it and returns a thumbprint - not yet implemented for node\r\n     */\n\n  }, {\n    key: \"getPublicKeyThumbprint\",\n    value: function getPublicKeyThumbprint() {\n      throw new Error(\"Method not implemented.\");\n    }\n    /**\r\n     * Removes cryptographic keypair from key store matching the keyId passed in\r\n     * @param kid\r\n     */\n\n  }, {\n    key: \"removeTokenBindingKey\",\n    value: function removeTokenBindingKey() {\n      throw new Error(\"Method not implemented.\");\n    }\n    /**\r\n     * Removes all cryptographic keys from Keystore\r\n     */\n\n  }, {\n    key: \"clearKeystore\",\n    value: function clearKeystore() {\n      throw new Error(\"Method not implemented.\");\n    }\n    /**\r\n     * Signs the given object as a jwt payload with private key retrieved by given kid - currently not implemented for node\r\n     */\n\n  }, {\n    key: \"signJwt\",\n    value: function signJwt() {\n      throw new Error(\"Method not implemented.\");\n    }\n    /**\r\n     * Returns the SHA-256 hash of an input string\r\n     */\n\n  }, {\n    key: \"hashString\",\n    value: function () {\n      var _hashString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(plainText) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(plainText).toString(\"base64\"), \"base64\"));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function hashString(_x6) {\n        return _hashString.apply(this, arguments);\n      }\n\n      return hashString;\n    }()\n  }]);\n\n  return CryptoProvider;\n}();\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * This class deserializes cache entities read from the file into in memory object types defined internally\r\n */\n\n\nvar Deserializer = /*#__PURE__*/function () {\n  function Deserializer() {\n    _classCallCheck(this, Deserializer);\n  }\n\n  _createClass(Deserializer, null, [{\n    key: \"deserializeJSONBlob\",\n    value:\n    /**\r\n     * Parse the JSON blob in memory and deserialize the content\r\n     * @param cachedJson\r\n     */\n    function deserializeJSONBlob(jsonFile) {\n      var deserializedCache = StringUtils.isEmpty(jsonFile) ? {} : JSON.parse(jsonFile);\n      return deserializedCache;\n    }\n    /**\r\n     * Deserializes accounts to AccountEntity objects\r\n     * @param accounts\r\n     */\n\n  }, {\n    key: \"deserializeAccounts\",\n    value: function deserializeAccounts(accounts) {\n      var accountObjects = {};\n\n      if (accounts) {\n        Object.keys(accounts).map(function (key) {\n          var serializedAcc = accounts[key];\n          var mappedAcc = {\n            homeAccountId: serializedAcc.home_account_id,\n            environment: serializedAcc.environment,\n            realm: serializedAcc.realm,\n            localAccountId: serializedAcc.local_account_id,\n            username: serializedAcc.username,\n            authorityType: serializedAcc.authority_type,\n            name: serializedAcc.name,\n            clientInfo: serializedAcc.client_info,\n            lastModificationTime: serializedAcc.last_modification_time,\n            lastModificationApp: serializedAcc.last_modification_app\n          };\n          var account = new AccountEntity();\n          CacheManager.toObject(account, mappedAcc);\n          accountObjects[key] = account;\n        });\n      }\n\n      return accountObjects;\n    }\n    /**\r\n     * Deserializes id tokens to IdTokenEntity objects\r\n     * @param idTokens\r\n     */\n\n  }, {\n    key: \"deserializeIdTokens\",\n    value: function deserializeIdTokens(idTokens) {\n      var idObjects = {};\n\n      if (idTokens) {\n        Object.keys(idTokens).map(function (key) {\n          var serializedIdT = idTokens[key];\n          var mappedIdT = {\n            homeAccountId: serializedIdT.home_account_id,\n            environment: serializedIdT.environment,\n            credentialType: serializedIdT.credential_type,\n            clientId: serializedIdT.client_id,\n            secret: serializedIdT.secret,\n            realm: serializedIdT.realm\n          };\n          var idToken = new IdTokenEntity();\n          CacheManager.toObject(idToken, mappedIdT);\n          idObjects[key] = idToken;\n        });\n      }\n\n      return idObjects;\n    }\n    /**\r\n     * Deserializes access tokens to AccessTokenEntity objects\r\n     * @param accessTokens\r\n     */\n\n  }, {\n    key: \"deserializeAccessTokens\",\n    value: function deserializeAccessTokens(accessTokens) {\n      var atObjects = {};\n\n      if (accessTokens) {\n        Object.keys(accessTokens).map(function (key) {\n          var serializedAT = accessTokens[key];\n          var mappedAT = {\n            homeAccountId: serializedAT.home_account_id,\n            environment: serializedAT.environment,\n            credentialType: serializedAT.credential_type,\n            clientId: serializedAT.client_id,\n            secret: serializedAT.secret,\n            realm: serializedAT.realm,\n            target: serializedAT.target,\n            cachedAt: serializedAT.cached_at,\n            expiresOn: serializedAT.expires_on,\n            extendedExpiresOn: serializedAT.extended_expires_on,\n            refreshOn: serializedAT.refresh_on,\n            keyId: serializedAT.key_id,\n            tokenType: serializedAT.token_type,\n            requestedClaims: serializedAT.requestedClaims,\n            requestedClaimsHash: serializedAT.requestedClaimsHash\n          };\n          var accessToken = new AccessTokenEntity();\n          CacheManager.toObject(accessToken, mappedAT);\n          atObjects[key] = accessToken;\n        });\n      }\n\n      return atObjects;\n    }\n    /**\r\n     * Deserializes refresh tokens to RefreshTokenEntity objects\r\n     * @param refreshTokens\r\n     */\n\n  }, {\n    key: \"deserializeRefreshTokens\",\n    value: function deserializeRefreshTokens(refreshTokens) {\n      var rtObjects = {};\n\n      if (refreshTokens) {\n        Object.keys(refreshTokens).map(function (key) {\n          var serializedRT = refreshTokens[key];\n          var mappedRT = {\n            homeAccountId: serializedRT.home_account_id,\n            environment: serializedRT.environment,\n            credentialType: serializedRT.credential_type,\n            clientId: serializedRT.client_id,\n            secret: serializedRT.secret,\n            familyId: serializedRT.family_id,\n            target: serializedRT.target,\n            realm: serializedRT.realm\n          };\n          var refreshToken = new RefreshTokenEntity();\n          CacheManager.toObject(refreshToken, mappedRT);\n          rtObjects[key] = refreshToken;\n        });\n      }\n\n      return rtObjects;\n    }\n    /**\r\n     * Deserializes appMetadata to AppMetaData objects\r\n     * @param appMetadata\r\n     */\n\n  }, {\n    key: \"deserializeAppMetadata\",\n    value: function deserializeAppMetadata(appMetadata) {\n      var appMetadataObjects = {};\n\n      if (appMetadata) {\n        Object.keys(appMetadata).map(function (key) {\n          var serializedAmdt = appMetadata[key];\n          var mappedAmd = {\n            clientId: serializedAmdt.client_id,\n            environment: serializedAmdt.environment,\n            familyId: serializedAmdt.family_id\n          };\n          var amd = new AppMetadataEntity();\n          CacheManager.toObject(amd, mappedAmd);\n          appMetadataObjects[key] = amd;\n        });\n      }\n\n      return appMetadataObjects;\n    }\n    /**\r\n     * Deserialize an inMemory Cache\r\n     * @param jsonCache\r\n     */\n\n  }, {\n    key: \"deserializeAllCache\",\n    value: function deserializeAllCache(jsonCache) {\n      return {\n        accounts: jsonCache.Account ? this.deserializeAccounts(jsonCache.Account) : {},\n        idTokens: jsonCache.IdToken ? this.deserializeIdTokens(jsonCache.IdToken) : {},\n        accessTokens: jsonCache.AccessToken ? this.deserializeAccessTokens(jsonCache.AccessToken) : {},\n        refreshTokens: jsonCache.RefreshToken ? this.deserializeRefreshTokens(jsonCache.RefreshToken) : {},\n        appMetadata: jsonCache.AppMetadata ? this.deserializeAppMetadata(jsonCache.AppMetadata) : {}\n      };\n    }\n  }]);\n\n  return Deserializer;\n}();\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n\nvar Serializer = /*#__PURE__*/function () {\n  function Serializer() {\n    _classCallCheck(this, Serializer);\n  }\n\n  _createClass(Serializer, null, [{\n    key: \"serializeJSONBlob\",\n    value:\n    /**\r\n     * serialize the JSON blob\r\n     * @param data\r\n     */\n    function serializeJSONBlob(data) {\n      return JSON.stringify(data);\n    }\n    /**\r\n     * Serialize Accounts\r\n     * @param accCache\r\n     */\n\n  }, {\n    key: \"serializeAccounts\",\n    value: function serializeAccounts(accCache) {\n      var accounts = {};\n      Object.keys(accCache).map(function (key) {\n        var accountEntity = accCache[key];\n        accounts[key] = {\n          home_account_id: accountEntity.homeAccountId,\n          environment: accountEntity.environment,\n          realm: accountEntity.realm,\n          local_account_id: accountEntity.localAccountId,\n          username: accountEntity.username,\n          authority_type: accountEntity.authorityType,\n          name: accountEntity.name,\n          client_info: accountEntity.clientInfo,\n          last_modification_time: accountEntity.lastModificationTime,\n          last_modification_app: accountEntity.lastModificationApp\n        };\n      });\n      return accounts;\n    }\n    /**\r\n     * Serialize IdTokens\r\n     * @param idTCache\r\n     */\n\n  }, {\n    key: \"serializeIdTokens\",\n    value: function serializeIdTokens(idTCache) {\n      var idTokens = {};\n      Object.keys(idTCache).map(function (key) {\n        var idTEntity = idTCache[key];\n        idTokens[key] = {\n          home_account_id: idTEntity.homeAccountId,\n          environment: idTEntity.environment,\n          credential_type: idTEntity.credentialType,\n          client_id: idTEntity.clientId,\n          secret: idTEntity.secret,\n          realm: idTEntity.realm\n        };\n      });\n      return idTokens;\n    }\n    /**\r\n     * Serializes AccessTokens\r\n     * @param atCache\r\n     */\n\n  }, {\n    key: \"serializeAccessTokens\",\n    value: function serializeAccessTokens(atCache) {\n      var accessTokens = {};\n      Object.keys(atCache).map(function (key) {\n        var atEntity = atCache[key];\n        accessTokens[key] = {\n          home_account_id: atEntity.homeAccountId,\n          environment: atEntity.environment,\n          credential_type: atEntity.credentialType,\n          client_id: atEntity.clientId,\n          secret: atEntity.secret,\n          realm: atEntity.realm,\n          target: atEntity.target,\n          cached_at: atEntity.cachedAt,\n          expires_on: atEntity.expiresOn,\n          extended_expires_on: atEntity.extendedExpiresOn,\n          refresh_on: atEntity.refreshOn,\n          key_id: atEntity.keyId,\n          token_type: atEntity.tokenType,\n          requestedClaims: atEntity.requestedClaims,\n          requestedClaimsHash: atEntity.requestedClaimsHash\n        };\n      });\n      return accessTokens;\n    }\n    /**\r\n     * Serialize refreshTokens\r\n     * @param rtCache\r\n     */\n\n  }, {\n    key: \"serializeRefreshTokens\",\n    value: function serializeRefreshTokens(rtCache) {\n      var refreshTokens = {};\n      Object.keys(rtCache).map(function (key) {\n        var rtEntity = rtCache[key];\n        refreshTokens[key] = {\n          home_account_id: rtEntity.homeAccountId,\n          environment: rtEntity.environment,\n          credential_type: rtEntity.credentialType,\n          client_id: rtEntity.clientId,\n          secret: rtEntity.secret,\n          family_id: rtEntity.familyId,\n          target: rtEntity.target,\n          realm: rtEntity.realm\n        };\n      });\n      return refreshTokens;\n    }\n    /**\r\n     * Serialize amdtCache\r\n     * @param amdtCache\r\n     */\n\n  }, {\n    key: \"serializeAppMetadata\",\n    value: function serializeAppMetadata(amdtCache) {\n      var appMetadata = {};\n      Object.keys(amdtCache).map(function (key) {\n        var amdtEntity = amdtCache[key];\n        appMetadata[key] = {\n          client_id: amdtEntity.clientId,\n          environment: amdtEntity.environment,\n          family_id: amdtEntity.familyId\n        };\n      });\n      return appMetadata;\n    }\n    /**\r\n     * Serialize the cache\r\n     * @param jsonContent\r\n     */\n\n  }, {\n    key: \"serializeAllCache\",\n    value: function serializeAllCache(inMemCache) {\n      return {\n        Account: this.serializeAccounts(inMemCache.accounts),\n        IdToken: this.serializeIdTokens(inMemCache.idTokens),\n        AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),\n        RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),\n        AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata)\n      };\n    }\n  }]);\n\n  return Serializer;\n}();\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * This class implements Storage for node, reading cache from user specified storage location or an  extension library\r\n * @public\r\n */\n\n\nvar NodeStorage = /*#__PURE__*/function (_CacheManager) {\n  _inherits(NodeStorage, _CacheManager);\n\n  var _super = _createSuper(NodeStorage);\n\n  function NodeStorage(logger, clientId, cryptoImpl) {\n    var _this;\n\n    _classCallCheck(this, NodeStorage);\n\n    _this = _super.call(this, clientId, cryptoImpl);\n    _this.cache = {};\n    _this.changeEmitters = [];\n    _this.logger = logger;\n    return _this;\n  }\n  /**\r\n   * Queue up callbacks\r\n   * @param func - a callback function for cache change indication\r\n   */\n\n\n  _createClass(NodeStorage, [{\n    key: \"registerChangeEmitter\",\n    value: function registerChangeEmitter(func) {\n      this.changeEmitters.push(func);\n    }\n    /**\r\n     * Invoke the callback when cache changes\r\n     */\n\n  }, {\n    key: \"emitChange\",\n    value: function emitChange() {\n      this.changeEmitters.forEach(function (func) {\n        return func.call(null);\n      });\n    }\n    /**\r\n     * Converts cacheKVStore to InMemoryCache\r\n     * @param cache - key value store\r\n     */\n\n  }, {\n    key: \"cacheToInMemoryCache\",\n    value: function cacheToInMemoryCache(cache) {\n      var inMemoryCache = {\n        accounts: {},\n        idTokens: {},\n        accessTokens: {},\n        refreshTokens: {},\n        appMetadata: {}\n      };\n\n      for (var key in cache) {\n        if (cache[key] instanceof AccountEntity) {\n          inMemoryCache.accounts[key] = cache[key];\n        } else if (cache[key] instanceof IdTokenEntity) {\n          inMemoryCache.idTokens[key] = cache[key];\n        } else if (cache[key] instanceof AccessTokenEntity) {\n          inMemoryCache.accessTokens[key] = cache[key];\n        } else if (cache[key] instanceof RefreshTokenEntity) {\n          inMemoryCache.refreshTokens[key] = cache[key];\n        } else if (cache[key] instanceof AppMetadataEntity) {\n          inMemoryCache.appMetadata[key] = cache[key];\n        } else {\n          continue;\n        }\n      }\n\n      return inMemoryCache;\n    }\n    /**\r\n     * converts inMemoryCache to CacheKVStore\r\n     * @param inMemoryCache - kvstore map for inmemory\r\n     */\n\n  }, {\n    key: \"inMemoryCacheToCache\",\n    value: function inMemoryCacheToCache(inMemoryCache) {\n      // convert in memory cache to a flat Key-Value map\n      var cache = this.getCache();\n      cache = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, cache), inMemoryCache.accounts), inMemoryCache.idTokens), inMemoryCache.accessTokens), inMemoryCache.refreshTokens), inMemoryCache.appMetadata); // convert in memory cache to a flat Key-Value map\n\n      return cache;\n    }\n    /**\r\n     * gets the current in memory cache for the client\r\n     */\n\n  }, {\n    key: \"getInMemoryCache\",\n    value: function getInMemoryCache() {\n      this.logger.trace(\"Getting in-memory cache\"); // convert the cache key value store to inMemoryCache\n\n      var inMemoryCache = this.cacheToInMemoryCache(this.getCache());\n      return inMemoryCache;\n    }\n    /**\r\n     * sets the current in memory cache for the client\r\n     * @param inMemoryCache - key value map in memory\r\n     */\n\n  }, {\n    key: \"setInMemoryCache\",\n    value: function setInMemoryCache(inMemoryCache) {\n      this.logger.trace(\"Setting in-memory cache\"); // convert and append the inMemoryCache to cacheKVStore\n\n      var cache = this.inMemoryCacheToCache(inMemoryCache);\n      this.setCache(cache);\n      this.emitChange();\n    }\n    /**\r\n     * get the current cache key-value store\r\n     */\n\n  }, {\n    key: \"getCache\",\n    value: function getCache() {\n      this.logger.trace(\"Getting cache key-value store\");\n      return this.cache;\n    }\n    /**\r\n     * sets the current cache (key value store)\r\n     * @param cacheMap - key value map\r\n     */\n\n  }, {\n    key: \"setCache\",\n    value: function setCache(cache) {\n      this.logger.trace(\"Setting cache key value store\");\n      this.cache = cache; // mark change in cache\n\n      this.emitChange();\n    }\n    /**\r\n     * Gets cache item with given key.\r\n     * @param key - lookup key for the cache entry\r\n     */\n\n  }, {\n    key: \"getItem\",\n    value: function getItem(key) {\n      this.logger.tracePii(\"Item key: \".concat(key)); // read cache\n\n      var cache = this.getCache();\n      return cache[key];\n    }\n    /**\r\n     * Gets cache item with given key-value\r\n     * @param key - lookup key for the cache entry\r\n     * @param value - value of the cache entry\r\n     */\n\n  }, {\n    key: \"setItem\",\n    value: function setItem(key, value) {\n      this.logger.tracePii(\"Item key: \".concat(key)); // read cache\n\n      var cache = this.getCache();\n      cache[key] = value; // write to cache\n\n      this.setCache(cache);\n    }\n    /**\r\n     * fetch the account entity\r\n     * @param accountKey - lookup key to fetch cache type AccountEntity\r\n     */\n\n  }, {\n    key: \"getAccount\",\n    value: function getAccount(accountKey) {\n      var account = this.getItem(accountKey);\n\n      if (AccountEntity.isAccountEntity(account)) {\n        return account;\n      }\n\n      return null;\n    }\n    /**\r\n     * set account entity\r\n     * @param account - cache value to be set of type AccountEntity\r\n     */\n\n  }, {\n    key: \"setAccount\",\n    value: function setAccount(account) {\n      var accountKey = account.generateAccountKey();\n      this.setItem(accountKey, account);\n    }\n    /**\r\n     * fetch the idToken credential\r\n     * @param idTokenKey - lookup key to fetch cache type IdTokenEntity\r\n     */\n\n  }, {\n    key: \"getIdTokenCredential\",\n    value: function getIdTokenCredential(idTokenKey) {\n      var idToken = this.getItem(idTokenKey);\n\n      if (IdTokenEntity.isIdTokenEntity(idToken)) {\n        return idToken;\n      }\n\n      return null;\n    }\n    /**\r\n     * set idToken credential\r\n     * @param idToken - cache value to be set of type IdTokenEntity\r\n     */\n\n  }, {\n    key: \"setIdTokenCredential\",\n    value: function setIdTokenCredential(idToken) {\n      var idTokenKey = idToken.generateCredentialKey();\n      this.setItem(idTokenKey, idToken);\n    }\n    /**\r\n     * fetch the accessToken credential\r\n     * @param accessTokenKey - lookup key to fetch cache type AccessTokenEntity\r\n     */\n\n  }, {\n    key: \"getAccessTokenCredential\",\n    value: function getAccessTokenCredential(accessTokenKey) {\n      var accessToken = this.getItem(accessTokenKey);\n\n      if (AccessTokenEntity.isAccessTokenEntity(accessToken)) {\n        return accessToken;\n      }\n\n      return null;\n    }\n    /**\r\n     * set accessToken credential\r\n     * @param accessToken -  cache value to be set of type AccessTokenEntity\r\n     */\n\n  }, {\n    key: \"setAccessTokenCredential\",\n    value: function setAccessTokenCredential(accessToken) {\n      var accessTokenKey = accessToken.generateCredentialKey();\n      this.setItem(accessTokenKey, accessToken);\n    }\n    /**\r\n     * fetch the refreshToken credential\r\n     * @param refreshTokenKey - lookup key to fetch cache type RefreshTokenEntity\r\n     */\n\n  }, {\n    key: \"getRefreshTokenCredential\",\n    value: function getRefreshTokenCredential(refreshTokenKey) {\n      var refreshToken = this.getItem(refreshTokenKey);\n\n      if (RefreshTokenEntity.isRefreshTokenEntity(refreshToken)) {\n        return refreshToken;\n      }\n\n      return null;\n    }\n    /**\r\n     * set refreshToken credential\r\n     * @param refreshToken - cache value to be set of type RefreshTokenEntity\r\n     */\n\n  }, {\n    key: \"setRefreshTokenCredential\",\n    value: function setRefreshTokenCredential(refreshToken) {\n      var refreshTokenKey = refreshToken.generateCredentialKey();\n      this.setItem(refreshTokenKey, refreshToken);\n    }\n    /**\r\n     * fetch appMetadata entity from the platform cache\r\n     * @param appMetadataKey - lookup key to fetch cache type AppMetadataEntity\r\n     */\n\n  }, {\n    key: \"getAppMetadata\",\n    value: function getAppMetadata(appMetadataKey) {\n      var appMetadata = this.getItem(appMetadataKey);\n\n      if (AppMetadataEntity.isAppMetadataEntity(appMetadataKey, appMetadata)) {\n        return appMetadata;\n      }\n\n      return null;\n    }\n    /**\r\n     * set appMetadata entity to the platform cache\r\n     * @param appMetadata - cache value to be set of type AppMetadataEntity\r\n     */\n\n  }, {\n    key: \"setAppMetadata\",\n    value: function setAppMetadata(appMetadata) {\n      var appMetadataKey = appMetadata.generateAppMetadataKey();\n      this.setItem(appMetadataKey, appMetadata);\n    }\n    /**\r\n     * fetch server telemetry entity from the platform cache\r\n     * @param serverTelemetrykey - lookup key to fetch cache type ServerTelemetryEntity\r\n     */\n\n  }, {\n    key: \"getServerTelemetry\",\n    value: function getServerTelemetry(serverTelemetrykey) {\n      var serverTelemetryEntity = this.getItem(serverTelemetrykey);\n\n      if (serverTelemetryEntity && ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)) {\n        return serverTelemetryEntity;\n      }\n\n      return null;\n    }\n    /**\r\n     * set server telemetry entity to the platform cache\r\n     * @param serverTelemetryKey - lookup key to fetch cache type ServerTelemetryEntity\r\n     * @param serverTelemetry - cache value to be set of type ServerTelemetryEntity\r\n     */\n\n  }, {\n    key: \"setServerTelemetry\",\n    value: function setServerTelemetry(serverTelemetryKey, serverTelemetry) {\n      this.setItem(serverTelemetryKey, serverTelemetry);\n    }\n    /**\r\n     * fetch authority metadata entity from the platform cache\r\n     * @param key - lookup key to fetch cache type AuthorityMetadataEntity\r\n     */\n\n  }, {\n    key: \"getAuthorityMetadata\",\n    value: function getAuthorityMetadata(key) {\n      var authorityMetadataEntity = this.getItem(key);\n\n      if (authorityMetadataEntity && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, authorityMetadataEntity)) {\n        return authorityMetadataEntity;\n      }\n\n      return null;\n    }\n    /**\r\n     * Get all authority metadata keys\r\n     */\n\n  }, {\n    key: \"getAuthorityMetadataKeys\",\n    value: function getAuthorityMetadataKeys() {\n      var _this2 = this;\n\n      return this.getKeys().filter(function (key) {\n        return _this2.isAuthorityMetadata(key);\n      });\n    }\n    /**\r\n     * set authority metadata entity to the platform cache\r\n     * @param key - lookup key to fetch cache type AuthorityMetadataEntity\r\n     * @param metadata - cache value to be set of type AuthorityMetadataEntity\r\n     */\n\n  }, {\n    key: \"setAuthorityMetadata\",\n    value: function setAuthorityMetadata(key, metadata) {\n      this.setItem(key, metadata);\n    }\n    /**\r\n     * fetch throttling entity from the platform cache\r\n     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity\r\n     */\n\n  }, {\n    key: \"getThrottlingCache\",\n    value: function getThrottlingCache(throttlingCacheKey) {\n      var throttlingCache = this.getItem(throttlingCacheKey);\n\n      if (throttlingCache && ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, throttlingCache)) {\n        return throttlingCache;\n      }\n\n      return null;\n    }\n    /**\r\n     * set throttling entity to the platform cache\r\n     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity\r\n     * @param throttlingCache - cache value to be set of type ThrottlingEntity\r\n     */\n\n  }, {\n    key: \"setThrottlingCache\",\n    value: function setThrottlingCache(throttlingCacheKey, throttlingCache) {\n      this.setItem(throttlingCacheKey, throttlingCache);\n    }\n    /**\r\n     * Removes the cache item from memory with the given key.\r\n     * @param key - lookup key to remove a cache entity\r\n     * @param inMemory - key value map of the cache\r\n     */\n\n  }, {\n    key: \"removeItem\",\n    value: function removeItem(key) {\n      this.logger.tracePii(\"Item key: \".concat(key)); // read inMemoryCache\n\n      var result = false;\n      var cache = this.getCache();\n\n      if (!!cache[key]) {\n        delete cache[key];\n        result = true;\n      } // write to the cache after removal\n\n\n      if (result) {\n        this.setCache(cache);\n        this.emitChange();\n      }\n\n      return result;\n    }\n    /**\r\n     * Checks whether key is in cache.\r\n     * @param key - look up key for a cache entity\r\n     */\n\n  }, {\n    key: \"containsKey\",\n    value: function containsKey(key) {\n      return this.getKeys().includes(key);\n    }\n    /**\r\n     * Gets all keys in window.\r\n     */\n\n  }, {\n    key: \"getKeys\",\n    value: function getKeys() {\n      this.logger.trace(\"Retrieving all cache keys\"); // read cache\n\n      var cache = this.getCache();\n      return _toConsumableArray(Object.keys(cache));\n    }\n    /**\r\n     * Clears all cache entries created by MSAL (except tokens).\r\n     */\n\n  }, {\n    key: \"clear\",\n    value: function () {\n      var _clear = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _this3 = this;\n\n        var cacheKeys;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                this.logger.trace(\"Clearing cache entries created by MSAL\"); // read inMemoryCache\n\n                cacheKeys = this.getKeys(); // delete each element\n\n                cacheKeys.forEach(function (key) {\n                  _this3.removeItem(key);\n                });\n                this.emitChange();\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function clear() {\n        return _clear.apply(this, arguments);\n      }\n\n      return clear;\n    }()\n    /**\r\n     * Initialize in memory cache from an exisiting cache vault\r\n     * @param cache - blob formatted cache (JSON)\r\n     */\n\n  }, {\n    key: \"updateCredentialCacheKey\",\n    value:\n    /**\r\n     * Updates a credential's cache key if the current cache key is outdated\r\n     */\n    function updateCredentialCacheKey(currentCacheKey, credential) {\n      var updatedCacheKey = credential.generateCredentialKey();\n\n      if (currentCacheKey !== updatedCacheKey) {\n        var cacheItem = this.getItem(currentCacheKey);\n\n        if (cacheItem) {\n          this.removeItem(currentCacheKey);\n          this.setItem(updatedCacheKey, cacheItem);\n          this.logger.verbose(\"Updated an outdated \".concat(credential.credentialType, \" cache key\"));\n          return updatedCacheKey;\n        } else {\n          this.logger.error(\"Attempted to update an outdated \".concat(credential.credentialType, \" cache key but no item matching the outdated key was found in storage\"));\n        }\n      }\n\n      return currentCacheKey;\n    }\n  }], [{\n    key: \"generateInMemoryCache\",\n    value: function generateInMemoryCache(cache) {\n      return Deserializer.deserializeAllCache(Deserializer.deserializeJSONBlob(cache));\n    }\n    /**\r\n     * retrieves the final JSON\r\n     * @param inMemoryCache - itemised cache read from the JSON\r\n     */\n\n  }, {\n    key: \"generateJsonCache\",\n    value: function generateJsonCache(inMemoryCache) {\n      return Serializer.serializeAllCache(inMemoryCache);\n    }\n  }]);\n\n  return NodeStorage;\n}(CacheManager);\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n\nvar defaultSerializedCache = {\n  Account: {},\n  IdToken: {},\n  AccessToken: {},\n  RefreshToken: {},\n  AppMetadata: {}\n};\n/**\r\n * In-memory token cache manager\r\n * @public\r\n */\n\nvar TokenCache = /*#__PURE__*/function () {\n  function TokenCache(storage, logger, cachePlugin) {\n    _classCallCheck(this, TokenCache);\n\n    this.cacheHasChanged = false;\n    this.storage = storage;\n    this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));\n\n    if (cachePlugin) {\n      this.persistence = cachePlugin;\n    }\n\n    this.logger = logger;\n  }\n  /**\r\n   * Set to true if cache state has changed since last time serialize or writeToPersistence was called\r\n   */\n\n\n  _createClass(TokenCache, [{\n    key: \"hasChanged\",\n    value: function hasChanged() {\n      return this.cacheHasChanged;\n    }\n    /**\r\n     * Serializes in memory cache to JSON\r\n     */\n\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      this.logger.trace(\"Serializing in-memory cache\");\n      var finalState = Serializer.serializeAllCache(this.storage.getInMemoryCache()); // if cacheSnapshot not null or empty, merge\n\n      if (!StringUtils.isEmpty(this.cacheSnapshot)) {\n        this.logger.trace(\"Reading cache snapshot from disk\");\n        finalState = this.mergeState(JSON.parse(this.cacheSnapshot), finalState);\n      } else {\n        this.logger.trace(\"No cache snapshot to merge\");\n      }\n\n      this.cacheHasChanged = false;\n      return JSON.stringify(finalState);\n    }\n    /**\r\n     * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format\r\n     * @param cache - blob formatted cache\r\n     */\n\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(cache) {\n      this.logger.trace(\"Deserializing JSON to in-memory cache\");\n      this.cacheSnapshot = cache;\n\n      if (!StringUtils.isEmpty(this.cacheSnapshot)) {\n        this.logger.trace(\"Reading cache snapshot from disk\");\n        var deserializedCache = Deserializer.deserializeAllCache(this.overlayDefaults(JSON.parse(this.cacheSnapshot)));\n        this.storage.setInMemoryCache(deserializedCache);\n      } else {\n        this.logger.trace(\"No cache snapshot to deserialize\");\n      }\n    }\n    /**\r\n     * Fetches the cache key-value map\r\n     */\n\n  }, {\n    key: \"getKVStore\",\n    value: function getKVStore() {\n      return this.storage.getCache();\n    }\n    /**\r\n     * API that retrieves all accounts currently in cache to the user\r\n     */\n\n  }, {\n    key: \"getAllAccounts\",\n    value: function () {\n      var _getAllAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var cacheContext;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                this.logger.trace(\"getAllAccounts called\");\n                _context6.prev = 1;\n\n                if (!this.persistence) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                cacheContext = new TokenCacheContext(this, false);\n                _context6.next = 6;\n                return this.persistence.beforeCacheAccess(cacheContext);\n\n              case 6:\n                return _context6.abrupt(\"return\", this.storage.getAllAccounts());\n\n              case 7:\n                _context6.prev = 7;\n\n                if (!(this.persistence && cacheContext)) {\n                  _context6.next = 11;\n                  break;\n                }\n\n                _context6.next = 11;\n                return this.persistence.afterCacheAccess(cacheContext);\n\n              case 11:\n                return _context6.finish(7);\n\n              case 12:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[1,, 7, 12]]);\n      }));\n\n      function getAllAccounts() {\n        return _getAllAccounts.apply(this, arguments);\n      }\n\n      return getAllAccounts;\n    }()\n    /**\r\n     * Returns the signed in account matching homeAccountId.\r\n     * (the account object is created at the time of successful login)\r\n     * or null when no matching account is found\r\n     * @param homeAccountId - unique identifier for an account (uid.utid)\r\n     */\n\n  }, {\n    key: \"getAccountByHomeId\",\n    value: function () {\n      var _getAccountByHomeId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(homeAccountId) {\n        var allAccounts;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.getAllAccounts();\n\n              case 2:\n                allAccounts = _context7.sent;\n\n                if (!(!StringUtils.isEmpty(homeAccountId) && allAccounts && allAccounts.length)) {\n                  _context7.next = 7;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", allAccounts.filter(function (accountObj) {\n                  return accountObj.homeAccountId === homeAccountId;\n                })[0] || null);\n\n              case 7:\n                return _context7.abrupt(\"return\", null);\n\n              case 8:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getAccountByHomeId(_x7) {\n        return _getAccountByHomeId.apply(this, arguments);\n      }\n\n      return getAccountByHomeId;\n    }()\n    /**\r\n     * Returns the signed in account matching localAccountId.\r\n     * (the account object is created at the time of successful login)\r\n     * or null when no matching account is found\r\n     * @param localAccountId - unique identifier of an account (sub/obj when homeAccountId cannot be populated)\r\n     */\n\n  }, {\n    key: \"getAccountByLocalId\",\n    value: function () {\n      var _getAccountByLocalId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(localAccountId) {\n        var allAccounts;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.getAllAccounts();\n\n              case 2:\n                allAccounts = _context8.sent;\n\n                if (!(!StringUtils.isEmpty(localAccountId) && allAccounts && allAccounts.length)) {\n                  _context8.next = 7;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", allAccounts.filter(function (accountObj) {\n                  return accountObj.localAccountId === localAccountId;\n                })[0] || null);\n\n              case 7:\n                return _context8.abrupt(\"return\", null);\n\n              case 8:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function getAccountByLocalId(_x8) {\n        return _getAccountByLocalId.apply(this, arguments);\n      }\n\n      return getAccountByLocalId;\n    }()\n    /**\r\n     * API to remove a specific account and the relevant data from cache\r\n     * @param account - AccountInfo passed by the user\r\n     */\n\n  }, {\n    key: \"removeAccount\",\n    value: function () {\n      var _removeAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(account) {\n        var cacheContext;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                this.logger.trace(\"removeAccount called\");\n                _context9.prev = 1;\n\n                if (!this.persistence) {\n                  _context9.next = 6;\n                  break;\n                }\n\n                cacheContext = new TokenCacheContext(this, true);\n                _context9.next = 6;\n                return this.persistence.beforeCacheAccess(cacheContext);\n\n              case 6:\n                _context9.next = 8;\n                return this.storage.removeAccount(AccountEntity.generateAccountCacheKey(account));\n\n              case 8:\n                _context9.prev = 8;\n\n                if (!(this.persistence && cacheContext)) {\n                  _context9.next = 12;\n                  break;\n                }\n\n                _context9.next = 12;\n                return this.persistence.afterCacheAccess(cacheContext);\n\n              case 12:\n                return _context9.finish(8);\n\n              case 13:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[1,, 8, 13]]);\n      }));\n\n      function removeAccount(_x9) {\n        return _removeAccount.apply(this, arguments);\n      }\n\n      return removeAccount;\n    }()\n    /**\r\n     * Called when the cache has changed state.\r\n     */\n\n  }, {\n    key: \"handleChangeEvent\",\n    value: function handleChangeEvent() {\n      this.cacheHasChanged = true;\n    }\n    /**\r\n     * Merge in memory cache with the cache snapshot.\r\n     * @param oldState - cache before changes\r\n     * @param currentState - current cache state in the library\r\n     */\n\n  }, {\n    key: \"mergeState\",\n    value: function mergeState(oldState, currentState) {\n      this.logger.trace(\"Merging in-memory cache with cache snapshot\");\n      var stateAfterRemoval = this.mergeRemovals(oldState, currentState);\n      return this.mergeUpdates(stateAfterRemoval, currentState);\n    }\n    /**\r\n     * Deep update of oldState based on newState values\r\n     * @param oldState - cache before changes\r\n     * @param newState - updated cache\r\n     */\n\n  }, {\n    key: \"mergeUpdates\",\n    value: function mergeUpdates(oldState, newState) {\n      var _this4 = this;\n\n      Object.keys(newState).forEach(function (newKey) {\n        var newValue = newState[newKey]; // if oldState does not contain value but newValue does, add it\n\n        if (!oldState.hasOwnProperty(newKey)) {\n          if (newValue !== null) {\n            oldState[newKey] = newValue;\n          }\n        } else {\n          // both oldState and newState contain the key, do deep update\n          var newValueNotNull = newValue !== null;\n          var newValueIsObject = typeof newValue === \"object\";\n          var newValueIsNotArray = !Array.isArray(newValue);\n          var oldStateNotUndefinedOrNull = typeof oldState[newKey] !== \"undefined\" && oldState[newKey] !== null;\n\n          if (newValueNotNull && newValueIsObject && newValueIsNotArray && oldStateNotUndefinedOrNull) {\n            _this4.mergeUpdates(oldState[newKey], newValue);\n          } else {\n            oldState[newKey] = newValue;\n          }\n        }\n      });\n      return oldState;\n    }\n    /**\r\n     * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of\r\n     * oldState that are not recognized, they are left untouched.\r\n     * @param oldState - cache before changes\r\n     * @param newState - updated cache\r\n     */\n\n  }, {\n    key: \"mergeRemovals\",\n    value: function mergeRemovals(oldState, newState) {\n      this.logger.trace(\"Remove updated entries in cache\");\n      var accounts = oldState.Account ? this.mergeRemovalsDict(oldState.Account, newState.Account) : oldState.Account;\n      var accessTokens = oldState.AccessToken ? this.mergeRemovalsDict(oldState.AccessToken, newState.AccessToken) : oldState.AccessToken;\n      var refreshTokens = oldState.RefreshToken ? this.mergeRemovalsDict(oldState.RefreshToken, newState.RefreshToken) : oldState.RefreshToken;\n      var idTokens = oldState.IdToken ? this.mergeRemovalsDict(oldState.IdToken, newState.IdToken) : oldState.IdToken;\n      var appMetadata = oldState.AppMetadata ? this.mergeRemovalsDict(oldState.AppMetadata, newState.AppMetadata) : oldState.AppMetadata;\n      return _objectSpread(_objectSpread({}, oldState), {}, {\n        Account: accounts,\n        AccessToken: accessTokens,\n        RefreshToken: refreshTokens,\n        IdToken: idTokens,\n        AppMetadata: appMetadata\n      });\n    }\n    /**\r\n     * Helper to merge new cache with the old one\r\n     * @param oldState - cache before changes\r\n     * @param newState - updated cache\r\n     */\n\n  }, {\n    key: \"mergeRemovalsDict\",\n    value: function mergeRemovalsDict(oldState, newState) {\n      var finalState = _objectSpread({}, oldState);\n\n      Object.keys(oldState).forEach(function (oldKey) {\n        if (!newState || !newState.hasOwnProperty(oldKey)) {\n          delete finalState[oldKey];\n        }\n      });\n      return finalState;\n    }\n    /**\r\n     * Helper to overlay as a part of cache merge\r\n     * @param passedInCache - cache read from the blob\r\n     */\n\n  }, {\n    key: \"overlayDefaults\",\n    value: function overlayDefaults(passedInCache) {\n      this.logger.trace(\"Overlaying input cache with the default cache\");\n      return {\n        Account: _objectSpread(_objectSpread({}, defaultSerializedCache.Account), passedInCache.Account),\n        IdToken: _objectSpread(_objectSpread({}, defaultSerializedCache.IdToken), passedInCache.IdToken),\n        AccessToken: _objectSpread(_objectSpread({}, defaultSerializedCache.AccessToken), passedInCache.AccessToken),\n        RefreshToken: _objectSpread(_objectSpread({}, defaultSerializedCache.RefreshToken), passedInCache.RefreshToken),\n        AppMetadata: _objectSpread(_objectSpread({}, defaultSerializedCache.AppMetadata), passedInCache.AppMetadata)\n      };\n    }\n  }]);\n\n  return TokenCache;\n}();\n/* eslint-disable header/header */\n\n\nvar name = \"@azure/msal-node\";\nvar version = \"1.14.0\";\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * NodeAuthErrorMessage class containing string constants used by error codes and messages.\r\n */\n\nvar NodeAuthErrorMessage = {\n  invalidLoopbackAddressType: {\n    code: \"invalid_loopback_server_address_type\",\n    desc: \"Loopback server address is not type string. This is unexpected.\"\n  },\n  unableToLoadRedirectUri: {\n    code: \"unable_to_load_redirectUrl\",\n    desc: \"Loopback server callback was invoked without a url. This is unexpected.\"\n  },\n  noAuthCodeInResponse: {\n    code: \"no_auth_code_in_response\",\n    desc: \"No auth code found in the server response. Please check your network trace to determine what happened.\"\n  },\n  noLoopbackServerExists: {\n    code: \"no_loopback_server_exists\",\n    desc: \"No loopback server exists yet.\"\n  },\n  loopbackServerAlreadyExists: {\n    code: \"loopback_server_already_exists\",\n    desc: \"Loopback server already exists. Cannot create another.\"\n  },\n  loopbackServerTimeout: {\n    code: \"loopback_server_timeout\",\n    desc: \"Timed out waiting for auth code listener to be registered.\"\n  },\n  stateNotFoundError: {\n    code: \"state_not_found\",\n    desc: \"State not found. Please verify that the request originated from msal.\"\n  }\n};\n\nvar NodeAuthError = /*#__PURE__*/function (_AuthError) {\n  _inherits(NodeAuthError, _AuthError);\n\n  var _super2 = _createSuper(NodeAuthError);\n\n  function NodeAuthError(errorCode, errorMessage) {\n    var _this5;\n\n    _classCallCheck(this, NodeAuthError);\n\n    _this5 = _super2.call(this, errorCode, errorMessage);\n    _this5.name = \"NodeAuthError\";\n    return _this5;\n  }\n  /**\r\n   * Creates an error thrown if loopback server address is of type string.\r\n   */\n\n\n  _createClass(NodeAuthError, null, [{\n    key: \"createInvalidLoopbackAddressTypeError\",\n    value: function createInvalidLoopbackAddressTypeError() {\n      return new NodeAuthError(NodeAuthErrorMessage.invalidLoopbackAddressType.code, \"\".concat(NodeAuthErrorMessage.invalidLoopbackAddressType.desc));\n    }\n    /**\r\n     * Creates an error thrown if the loopback server is unable to get a url.\r\n     */\n\n  }, {\n    key: \"createUnableToLoadRedirectUrlError\",\n    value: function createUnableToLoadRedirectUrlError() {\n      return new NodeAuthError(NodeAuthErrorMessage.unableToLoadRedirectUri.code, \"\".concat(NodeAuthErrorMessage.unableToLoadRedirectUri.desc));\n    }\n    /**\r\n     * Creates an error thrown if the server response does not contain an auth code.\r\n     */\n\n  }, {\n    key: \"createNoAuthCodeInResponseError\",\n    value: function createNoAuthCodeInResponseError() {\n      return new NodeAuthError(NodeAuthErrorMessage.noAuthCodeInResponse.code, \"\".concat(NodeAuthErrorMessage.noAuthCodeInResponse.desc));\n    }\n    /**\r\n     * Creates an error thrown if the loopback server has not been spun up yet.\r\n     */\n\n  }, {\n    key: \"createNoLoopbackServerExistsError\",\n    value: function createNoLoopbackServerExistsError() {\n      return new NodeAuthError(NodeAuthErrorMessage.noLoopbackServerExists.code, \"\".concat(NodeAuthErrorMessage.noLoopbackServerExists.desc));\n    }\n    /**\r\n     * Creates an error thrown if a loopback server already exists when attempting to create another one.\r\n     */\n\n  }, {\n    key: \"createLoopbackServerAlreadyExistsError\",\n    value: function createLoopbackServerAlreadyExistsError() {\n      return new NodeAuthError(NodeAuthErrorMessage.loopbackServerAlreadyExists.code, \"\".concat(NodeAuthErrorMessage.loopbackServerAlreadyExists.desc));\n    }\n    /**\r\n     * Creates an error thrown if the loopback server times out registering the auth code listener.\r\n     */\n\n  }, {\n    key: \"createLoopbackServerTimeoutError\",\n    value: function createLoopbackServerTimeoutError() {\n      return new NodeAuthError(NodeAuthErrorMessage.loopbackServerTimeout.code, \"\".concat(NodeAuthErrorMessage.loopbackServerTimeout.desc));\n    }\n    /**\r\n     * Creates an error thrown when the state is not present.\r\n     */\n\n  }, {\n    key: \"createStateNotFoundError\",\n    value: function createStateNotFoundError() {\n      return new NodeAuthError(NodeAuthErrorMessage.stateNotFoundError.code, NodeAuthErrorMessage.stateNotFoundError.desc);\n    }\n  }]);\n\n  return NodeAuthError;\n}(AuthError);\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Base abstract class for all ClientApplications - public and confidential\r\n * @public\r\n */\n\n\nvar ClientApplication = /*#__PURE__*/function () {\n  /**\r\n   * Constructor for the ClientApplication\r\n   */\n  function ClientApplication(configuration) {\n    _classCallCheck(this, ClientApplication);\n\n    this.config = buildAppConfiguration(configuration);\n    this.cryptoProvider = new CryptoProvider();\n    this.logger = new Logger(this.config.system.loggerOptions, name, version);\n    this.storage = new NodeStorage(this.logger, this.config.auth.clientId, this.cryptoProvider);\n    this.tokenCache = new TokenCache(this.storage, this.logger, this.config.cache.cachePlugin);\n  }\n  /**\r\n   * Creates the URL of the authorization request, letting the user input credentials and consent to the\r\n   * application. The URL targets the /authorize endpoint of the authority configured in the\r\n   * application object.\r\n   *\r\n   * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n   * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n   * `acquireTokenByCode(AuthorizationCodeRequest)`.\r\n   */\n\n\n  _createClass(ClientApplication, [{\n    key: \"getAuthCodeUrl\",\n    value: function () {\n      var _getAuthCodeUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(request) {\n        var validRequest, authClientConfig, authorizationCodeClient;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                this.logger.info(\"getAuthCodeUrl called\", request.correlationId);\n                _context10.t0 = _objectSpread;\n                _context10.t1 = _objectSpread;\n                _context10.t2 = _objectSpread({}, request);\n                _context10.next = 6;\n                return this.initializeBaseRequest(request);\n\n              case 6:\n                _context10.t3 = _context10.sent;\n                _context10.t4 = (0, _context10.t1)(_context10.t2, _context10.t3);\n                _context10.t5 = {};\n                _context10.t6 = {\n                  responseMode: request.responseMode || ResponseMode.QUERY,\n                  authenticationScheme: AuthenticationScheme.BEARER\n                };\n                validRequest = (0, _context10.t0)(_context10.t4, _context10.t5, _context10.t6);\n                _context10.next = 13;\n                return this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, undefined, undefined, request.azureCloudOptions);\n\n              case 13:\n                authClientConfig = _context10.sent;\n                authorizationCodeClient = new AuthorizationCodeClient(authClientConfig);\n                this.logger.verbose(\"Auth code client created\", validRequest.correlationId);\n                return _context10.abrupt(\"return\", authorizationCodeClient.getAuthCodeUrl(validRequest));\n\n              case 17:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function getAuthCodeUrl(_x10) {\n        return _getAuthCodeUrl.apply(this, arguments);\n      }\n\n      return getAuthCodeUrl;\n    }()\n    /**\r\n     * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0\r\n     * Authorization Code flow.\r\n     *\r\n     * `getAuthCodeUrl(AuthorizationCodeUrlRequest)` can be used to create the URL for the first step of OAuth2.0\r\n     * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and\r\n     * AuthorizationCodeRequest are the same.\r\n     */\n\n  }, {\n    key: \"acquireTokenByCode\",\n    value: function () {\n      var _acquireTokenByCode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(request, authCodePayLoad) {\n        var validRequest, serverTelemetryManager, authClientConfig, authorizationCodeClient;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                this.logger.info(\"acquireTokenByCode called\");\n\n                if (request.state && authCodePayLoad) {\n                  this.logger.info(\"acquireTokenByCode - validating state\");\n                  this.validateState(request.state, authCodePayLoad.state || \"\"); // eslint-disable-next-line no-param-reassign\n\n                  authCodePayLoad = _objectSpread(_objectSpread({}, authCodePayLoad), {}, {\n                    state: \"\"\n                  });\n                }\n\n                _context11.t0 = _objectSpread;\n                _context11.t1 = _objectSpread;\n                _context11.t2 = _objectSpread({}, request);\n                _context11.next = 7;\n                return this.initializeBaseRequest(request);\n\n              case 7:\n                _context11.t3 = _context11.sent;\n                _context11.t4 = (0, _context11.t1)(_context11.t2, _context11.t3);\n                _context11.t5 = {};\n                _context11.t6 = {\n                  authenticationScheme: AuthenticationScheme.BEARER\n                };\n                validRequest = (0, _context11.t0)(_context11.t4, _context11.t5, _context11.t6);\n                serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByCode, validRequest.correlationId);\n                _context11.prev = 13;\n                _context11.next = 16;\n                return this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, undefined, request.azureCloudOptions);\n\n              case 16:\n                authClientConfig = _context11.sent;\n                authorizationCodeClient = new AuthorizationCodeClient(authClientConfig);\n                this.logger.verbose(\"Auth code client created\", validRequest.correlationId);\n                return _context11.abrupt(\"return\", authorizationCodeClient.acquireToken(validRequest, authCodePayLoad));\n\n              case 22:\n                _context11.prev = 22;\n                _context11.t7 = _context11[\"catch\"](13);\n\n                if (_context11.t7 instanceof AuthError) {\n                  _context11.t7.setCorrelationId(validRequest.correlationId);\n                }\n\n                serverTelemetryManager.cacheFailedRequest(_context11.t7);\n                throw _context11.t7;\n\n              case 27:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[13, 22]]);\n      }));\n\n      function acquireTokenByCode(_x11, _x12) {\n        return _acquireTokenByCode.apply(this, arguments);\n      }\n\n      return acquireTokenByCode;\n    }()\n    /**\r\n     * Acquires a token by exchanging the refresh token provided for a new set of tokens.\r\n     *\r\n     * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Otherwise, it is\r\n     * recommended that you use `acquireTokenSilent()` for silent scenarios. When using `acquireTokenSilent()`, MSAL will\r\n     * handle the caching and refreshing of tokens automatically.\r\n     */\n\n  }, {\n    key: \"acquireTokenByRefreshToken\",\n    value: function () {\n      var _acquireTokenByRefreshToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(request) {\n        var validRequest, serverTelemetryManager, refreshTokenClientConfig, refreshTokenClient;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                this.logger.info(\"acquireTokenByRefreshToken called\", request.correlationId);\n                _context12.t0 = _objectSpread;\n                _context12.t1 = _objectSpread;\n                _context12.t2 = _objectSpread({}, request);\n                _context12.next = 6;\n                return this.initializeBaseRequest(request);\n\n              case 6:\n                _context12.t3 = _context12.sent;\n                _context12.t4 = (0, _context12.t1)(_context12.t2, _context12.t3);\n                _context12.t5 = {};\n                _context12.t6 = {\n                  authenticationScheme: AuthenticationScheme.BEARER\n                };\n                validRequest = (0, _context12.t0)(_context12.t4, _context12.t5, _context12.t6);\n                serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByRefreshToken, validRequest.correlationId);\n                _context12.prev = 12;\n                _context12.next = 15;\n                return this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, undefined, request.azureCloudOptions);\n\n              case 15:\n                refreshTokenClientConfig = _context12.sent;\n                refreshTokenClient = new RefreshTokenClient(refreshTokenClientConfig);\n                this.logger.verbose(\"Refresh token client created\", validRequest.correlationId);\n                return _context12.abrupt(\"return\", refreshTokenClient.acquireToken(validRequest));\n\n              case 21:\n                _context12.prev = 21;\n                _context12.t7 = _context12[\"catch\"](12);\n\n                if (_context12.t7 instanceof AuthError) {\n                  _context12.t7.setCorrelationId(validRequest.correlationId);\n                }\n\n                serverTelemetryManager.cacheFailedRequest(_context12.t7);\n                throw _context12.t7;\n\n              case 26:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[12, 21]]);\n      }));\n\n      function acquireTokenByRefreshToken(_x13) {\n        return _acquireTokenByRefreshToken.apply(this, arguments);\n      }\n\n      return acquireTokenByRefreshToken;\n    }()\n    /**\r\n     * Acquires a token silently when a user specifies the account the token is requested for.\r\n     *\r\n     * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.\r\n     * There is also an optional \"forceRefresh\" boolean the user can send to bypass the cache for access_token and id_token.\r\n     * In case the refresh_token is expired or not found, an error is thrown\r\n     * and the guidance is for the user to call any interactive token acquisition API (eg: `acquireTokenByCode()`).\r\n     */\n\n  }, {\n    key: \"acquireTokenSilent\",\n    value: function () {\n      var _acquireTokenSilent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(request) {\n        var validRequest, serverTelemetryManager, silentFlowClientConfig, silentFlowClient;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.t0 = _objectSpread;\n                _context13.t1 = _objectSpread;\n                _context13.t2 = _objectSpread({}, request);\n                _context13.next = 5;\n                return this.initializeBaseRequest(request);\n\n              case 5:\n                _context13.t3 = _context13.sent;\n                _context13.t4 = (0, _context13.t1)(_context13.t2, _context13.t3);\n                _context13.t5 = {};\n                _context13.t6 = {\n                  forceRefresh: request.forceRefresh || false\n                };\n                validRequest = (0, _context13.t0)(_context13.t4, _context13.t5, _context13.t6);\n                serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent, validRequest.correlationId, validRequest.forceRefresh);\n                _context13.prev = 11;\n                _context13.next = 14;\n                return this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, undefined, request.azureCloudOptions);\n\n              case 14:\n                silentFlowClientConfig = _context13.sent;\n                silentFlowClient = new SilentFlowClient(silentFlowClientConfig);\n                this.logger.verbose(\"Silent flow client created\", validRequest.correlationId);\n                return _context13.abrupt(\"return\", silentFlowClient.acquireToken(validRequest));\n\n              case 20:\n                _context13.prev = 20;\n                _context13.t7 = _context13[\"catch\"](11);\n\n                if (_context13.t7 instanceof AuthError) {\n                  _context13.t7.setCorrelationId(validRequest.correlationId);\n                }\n\n                serverTelemetryManager.cacheFailedRequest(_context13.t7);\n                throw _context13.t7;\n\n              case 25:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[11, 20]]);\n      }));\n\n      function acquireTokenSilent(_x14) {\n        return _acquireTokenSilent.apply(this, arguments);\n      }\n\n      return acquireTokenSilent;\n    }()\n    /**\r\n     * Acquires tokens with password grant by exchanging client applications username and password for credentials\r\n     *\r\n     * The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.\r\n     * More details on this recommendation at https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4\r\n     * Microsoft's documentation and recommendations are at:\r\n     * https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-authentication-flows#usernamepassword\r\n     *\r\n     * @param request - UsenamePasswordRequest\r\n     */\n\n  }, {\n    key: \"acquireTokenByUsernamePassword\",\n    value: function () {\n      var _acquireTokenByUsernamePassword = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(request) {\n        var validRequest, serverTelemetryManager, usernamePasswordClientConfig, usernamePasswordClient;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                this.logger.info(\"acquireTokenByUsernamePassword called\", request.correlationId);\n                _context14.t0 = _objectSpread;\n                _context14.t1 = _objectSpread({}, request);\n                _context14.next = 5;\n                return this.initializeBaseRequest(request);\n\n              case 5:\n                _context14.t2 = _context14.sent;\n                validRequest = (0, _context14.t0)(_context14.t1, _context14.t2);\n                serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByUsernamePassword, validRequest.correlationId);\n                _context14.prev = 8;\n                _context14.next = 11;\n                return this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, undefined, request.azureCloudOptions);\n\n              case 11:\n                usernamePasswordClientConfig = _context14.sent;\n                usernamePasswordClient = new UsernamePasswordClient(usernamePasswordClientConfig);\n                this.logger.verbose(\"Username password client created\", validRequest.correlationId);\n                return _context14.abrupt(\"return\", usernamePasswordClient.acquireToken(validRequest));\n\n              case 17:\n                _context14.prev = 17;\n                _context14.t3 = _context14[\"catch\"](8);\n\n                if (_context14.t3 instanceof AuthError) {\n                  _context14.t3.setCorrelationId(validRequest.correlationId);\n                }\n\n                serverTelemetryManager.cacheFailedRequest(_context14.t3);\n                throw _context14.t3;\n\n              case 22:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this, [[8, 17]]);\n      }));\n\n      function acquireTokenByUsernamePassword(_x15) {\n        return _acquireTokenByUsernamePassword.apply(this, arguments);\n      }\n\n      return acquireTokenByUsernamePassword;\n    }()\n    /**\r\n     * Gets the token cache for the application.\r\n     */\n\n  }, {\n    key: \"getTokenCache\",\n    value: function getTokenCache() {\n      this.logger.info(\"getTokenCache called\");\n      return this.tokenCache;\n    }\n    /**\r\n     * Validates OIDC state by comparing the user cached state with the state received from the server.\r\n     *\r\n     * This API is provided for scenarios where you would use OAuth2.0 state parameter to mitigate against\r\n     * CSRF attacks.\r\n     * For more information about state, visit https://datatracker.ietf.org/doc/html/rfc6819#section-3.6.\r\n     * @param state\r\n     * @param cachedState\r\n     */\n\n  }, {\n    key: \"validateState\",\n    value: function validateState(state, cachedState) {\n      if (!state) {\n        throw NodeAuthError.createStateNotFoundError();\n      }\n\n      if (state !== cachedState) {\n        throw ClientAuthError.createStateMismatchError();\n      }\n    }\n    /**\r\n     * Returns the logger instance\r\n     */\n\n  }, {\n    key: \"getLogger\",\n    value: function getLogger() {\n      return this.logger;\n    }\n    /**\r\n     * Replaces the default logger set in configurations with new Logger with new configurations\r\n     * @param logger - Logger instance\r\n     */\n\n  }, {\n    key: \"setLogger\",\n    value: function setLogger(logger) {\n      this.logger = logger;\n    }\n    /**\r\n     * Builds the common configuration to be passed to the common component based on the platform configurarion\r\n     * @param authority - user passed authority in configuration\r\n     * @param serverTelemetryManager - initializes servertelemetry if passed\r\n     */\n\n  }, {\n    key: \"buildOauthClientConfiguration\",\n    value: function () {\n      var _buildOauthClientConfiguration = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(authority, requestCorrelationId, serverTelemetryManager, azureRegionConfiguration, azureCloudOptions) {\n        var userAzureCloudOptions, discoveredAuthority, clientConfiguration;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                this.logger.verbose(\"buildOauthClientConfiguration called\", requestCorrelationId); // precedence - azureCloudInstance + tenant >> authority and request  >> config\n\n                userAzureCloudOptions = azureCloudOptions ? azureCloudOptions : this.config.auth.azureCloudOptions; // using null assertion operator as we ensure that all config values have default values in buildConfiguration()\n\n                this.logger.verbose(\"building oauth client configuration with the authority: \".concat(authority), requestCorrelationId);\n                _context15.next = 5;\n                return this.createAuthority(authority, azureRegionConfiguration, requestCorrelationId, userAzureCloudOptions);\n\n              case 5:\n                discoveredAuthority = _context15.sent;\n                serverTelemetryManager == null ? void 0 : serverTelemetryManager.updateRegionDiscoveryMetadata(discoveredAuthority.regionDiscoveryMetadata);\n                clientConfiguration = {\n                  authOptions: {\n                    clientId: this.config.auth.clientId,\n                    authority: discoveredAuthority,\n                    clientCapabilities: this.config.auth.clientCapabilities\n                  },\n                  systemOptions: {\n                    proxyUrl: this.config.system.proxyUrl\n                  },\n                  loggerOptions: {\n                    logLevel: this.config.system.loggerOptions.logLevel,\n                    loggerCallback: this.config.system.loggerOptions.loggerCallback,\n                    piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,\n                    correlationId: requestCorrelationId\n                  },\n                  cryptoInterface: this.cryptoProvider,\n                  networkInterface: this.config.system.networkClient,\n                  storageInterface: this.storage,\n                  serverTelemetryManager: serverTelemetryManager,\n                  clientCredentials: {\n                    clientSecret: this.clientSecret,\n                    clientAssertion: this.clientAssertion ? this.getClientAssertion(discoveredAuthority) : undefined\n                  },\n                  libraryInfo: {\n                    sku: Constants.MSAL_SKU,\n                    version: version,\n                    cpu: process.arch || Constants$1.EMPTY_STRING,\n                    os: process.platform || Constants$1.EMPTY_STRING\n                  },\n                  telemetry: this.config.telemetry,\n                  persistencePlugin: this.config.cache.cachePlugin,\n                  serializableCache: this.tokenCache\n                };\n                return _context15.abrupt(\"return\", clientConfiguration);\n\n              case 9:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function buildOauthClientConfiguration(_x16, _x17, _x18, _x19, _x20) {\n        return _buildOauthClientConfiguration.apply(this, arguments);\n      }\n\n      return buildOauthClientConfiguration;\n    }()\n  }, {\n    key: \"getClientAssertion\",\n    value: function getClientAssertion(authority) {\n      return {\n        assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, authority.tokenEndpoint),\n        assertionType: Constants.JWT_BEARER_ASSERTION_TYPE\n      };\n    }\n    /**\r\n     * Generates a request with the default scopes & generates a correlationId.\r\n     * @param authRequest - BaseAuthRequest for initialization\r\n     */\n\n  }, {\n    key: \"initializeBaseRequest\",\n    value: function () {\n      var _initializeBaseRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(authRequest) {\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                this.logger.verbose(\"initializeRequestScopes called\", authRequest.correlationId); // Default authenticationScheme to Bearer, log that POP isn't supported yet\n\n                if (authRequest.authenticationScheme && authRequest.authenticationScheme === AuthenticationScheme.POP) {\n                  this.logger.verbose(\"Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request\", authRequest.correlationId);\n                }\n\n                authRequest.authenticationScheme = AuthenticationScheme.BEARER; // Set requested claims hash if claims were requested\n\n                if (!(authRequest.claims && !StringUtils.isEmpty(authRequest.claims))) {\n                  _context16.next = 7;\n                  break;\n                }\n\n                _context16.next = 6;\n                return this.cryptoProvider.hashString(authRequest.claims);\n\n              case 6:\n                authRequest.requestedClaimsHash = _context16.sent;\n\n              case 7:\n                return _context16.abrupt(\"return\", _objectSpread(_objectSpread({}, authRequest), {}, {\n                  scopes: [].concat(_toConsumableArray(authRequest && authRequest.scopes || []), _toConsumableArray(OIDC_DEFAULT_SCOPES)),\n                  correlationId: authRequest && authRequest.correlationId || this.cryptoProvider.createNewGuid(),\n                  authority: authRequest.authority || this.config.auth.authority\n                }));\n\n              case 8:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function initializeBaseRequest(_x21) {\n        return _initializeBaseRequest.apply(this, arguments);\n      }\n\n      return initializeBaseRequest;\n    }()\n    /**\r\n     * Initializes the server telemetry payload\r\n     * @param apiId - Id for a specific request\r\n     * @param correlationId - GUID\r\n     * @param forceRefresh - boolean to indicate network call\r\n     */\n\n  }, {\n    key: \"initializeServerTelemetryManager\",\n    value: function initializeServerTelemetryManager(apiId, correlationId, forceRefresh) {\n      var telemetryPayload = {\n        clientId: this.config.auth.clientId,\n        correlationId: correlationId,\n        apiId: apiId,\n        forceRefresh: forceRefresh || false\n      };\n      return new ServerTelemetryManager(telemetryPayload, this.storage);\n    }\n    /**\r\n     * Create authority instance. If authority not passed in request, default to authority set on the application\r\n     * object. If no authority set in application object, then default to common authority.\r\n     * @param authorityString - authority from user configuration\r\n     */\n\n  }, {\n    key: \"createAuthority\",\n    value: function () {\n      var _createAuthority = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(authorityString, azureRegionConfiguration, requestCorrelationId, azureCloudOptions) {\n        var authorityUrl, authorityOptions;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                this.logger.verbose(\"createAuthority called\", requestCorrelationId); // build authority string based on auth params - azureCloudInstance is prioritized if provided\n\n                authorityUrl = Authority.generateAuthority(authorityString, azureCloudOptions);\n                authorityOptions = {\n                  protocolMode: this.config.auth.protocolMode,\n                  knownAuthorities: this.config.auth.knownAuthorities,\n                  cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n                  authorityMetadata: this.config.auth.authorityMetadata,\n                  azureRegionConfiguration: azureRegionConfiguration,\n                  skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache\n                };\n                _context17.next = 5;\n                return AuthorityFactory.createDiscoveredInstance(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.config.system.proxyUrl);\n\n              case 5:\n                return _context17.abrupt(\"return\", _context17.sent);\n\n              case 6:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function createAuthority(_x22, _x23, _x24, _x25) {\n        return _createAuthority.apply(this, arguments);\n      }\n\n      return createAuthority;\n    }()\n    /**\r\n     * Clear the cache\r\n     */\n\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      this.storage.clear();\n    }\n  }]);\n\n  return ClientApplication;\n}();\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n\nvar LoopbackClient = /*#__PURE__*/function () {\n  function LoopbackClient() {\n    _classCallCheck(this, LoopbackClient);\n  }\n\n  _createClass(LoopbackClient, [{\n    key: \"listenForAuthCode\",\n    value:\n    /**\r\n     * Spins up a loopback server which returns the server response when the localhost redirectUri is hit\r\n     * @param successTemplate\r\n     * @param errorTemplate\r\n     * @returns\r\n     */\n    function () {\n      var _listenForAuthCode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(successTemplate, errorTemplate) {\n        var _this6 = this;\n\n        var authCodeListener;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                if (!this.server) {\n                  _context19.next = 2;\n                  break;\n                }\n\n                throw NodeAuthError.createLoopbackServerAlreadyExistsError();\n\n              case 2:\n                authCodeListener = new Promise(function (resolve, reject) {\n                  _this6.server = createServer( /*#__PURE__*/function () {\n                    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(req, res) {\n                      var url, authCodeResponse, redirectUri;\n                      return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n                        while (1) {\n                          switch (_context18.prev = _context18.next) {\n                            case 0:\n                              url = req.url;\n\n                              if (url) {\n                                _context18.next = 7;\n                                break;\n                              }\n\n                              res.end(errorTemplate || \"Error occurred loading redirectUrl\");\n                              reject(NodeAuthError.createUnableToLoadRedirectUrlError());\n                              return _context18.abrupt(\"return\");\n\n                            case 7:\n                              if (!(url === Constants$1.FORWARD_SLASH)) {\n                                _context18.next = 10;\n                                break;\n                              }\n\n                              res.end(successTemplate || \"Auth code was successfully acquired. You can close this window now.\");\n                              return _context18.abrupt(\"return\");\n\n                            case 10:\n                              authCodeResponse = UrlString.getDeserializedQueryString(url);\n\n                              if (!authCodeResponse.code) {\n                                _context18.next = 17;\n                                break;\n                              }\n\n                              _context18.next = 14;\n                              return _this6.getRedirectUri();\n\n                            case 14:\n                              redirectUri = _context18.sent;\n                              res.writeHead(HttpStatus.REDIRECT, {\n                                location: redirectUri\n                              }); // Prevent auth code from being saved in the browser history\n\n                              res.end();\n\n                            case 17:\n                              resolve(authCodeResponse);\n\n                            case 18:\n                            case \"end\":\n                              return _context18.stop();\n                          }\n                        }\n                      }, _callee18);\n                    }));\n\n                    return function (_x28, _x29) {\n                      return _ref2.apply(this, arguments);\n                    };\n                  }());\n\n                  _this6.server.listen(0); // Listen on any available port\n\n                }); // Wait for server to be listening\n\n                _context19.next = 5;\n                return new Promise(function (resolve) {\n                  var ticks = 0;\n                  var id = setInterval(function () {\n                    if (LOOPBACK_SERVER_CONSTANTS.TIMEOUT_MS / LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS < ticks) {\n                      throw NodeAuthError.createLoopbackServerTimeoutError();\n                    }\n\n                    if (_this6.server.listening) {\n                      clearInterval(id);\n                      resolve();\n                    }\n\n                    ticks++;\n                  }, LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS);\n                });\n\n              case 5:\n                return _context19.abrupt(\"return\", authCodeListener);\n\n              case 6:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function listenForAuthCode(_x26, _x27) {\n        return _listenForAuthCode.apply(this, arguments);\n      }\n\n      return listenForAuthCode;\n    }()\n    /**\r\n     * Get the port that the loopback server is running on\r\n     * @returns\r\n     */\n\n  }, {\n    key: \"getRedirectUri\",\n    value: function getRedirectUri() {\n      if (!this.server) {\n        throw NodeAuthError.createNoLoopbackServerExistsError();\n      }\n\n      var address = this.server.address();\n\n      if (!address || typeof address === \"string\" || !address.port) {\n        this.closeServer();\n        throw NodeAuthError.createInvalidLoopbackAddressTypeError();\n      }\n\n      var port = address && address.port;\n      return \"\".concat(Constants.HTTP_PROTOCOL).concat(Constants.LOCALHOST, \":\").concat(port);\n    }\n    /**\r\n     * Close the loopback server\r\n     */\n\n  }, {\n    key: \"closeServer\",\n    value: function closeServer() {\n      if (!!this.server) {\n        this.server.close();\n      }\n    }\n  }]);\n\n  return LoopbackClient;\n}();\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * This class is to be used to acquire tokens for public client applications (desktop, mobile). Public client applications\r\n * are not trusted to safely store application secrets, and therefore can only request tokens in the name of an user.\r\n * @public\r\n */\n\n\nvar PublicClientApplication = /*#__PURE__*/function (_ClientApplication) {\n  _inherits(PublicClientApplication, _ClientApplication);\n\n  var _super3 = _createSuper(PublicClientApplication);\n\n  /**\r\n   * Important attributes in the Configuration object for auth are:\r\n   * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal.\r\n   * - authority: the authority URL for your application.\r\n   *\r\n   * AAD authorities are of the form https://login.microsoftonline.com/\\{Enter_the_Tenant_Info_Here\\}.\r\n   * - If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\r\n   * - If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\r\n   * - If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\r\n   * - To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\r\n   *\r\n   * Azure B2C authorities are of the form https://\\{instance\\}/\\{tenant\\}/\\{policy\\}. Each policy is considered\r\n   * its own authority. You will have to set the all of the knownAuthorities at the time of the client application\r\n   * construction.\r\n   *\r\n   * ADFS authorities are of the form https://\\{instance\\}/adfs.\r\n   */\n  function PublicClientApplication(configuration) {\n    _classCallCheck(this, PublicClientApplication);\n\n    return _super3.call(this, configuration);\n  }\n  /**\r\n   * Acquires a token from the authority using OAuth2.0 device code flow.\r\n   * This flow is designed for devices that do not have access to a browser or have input constraints.\r\n   * The authorization server issues a DeviceCode object with a verification code, an end-user code,\r\n   * and the end-user verification URI. The DeviceCode object is provided through a callback, and the end-user should be\r\n   * instructed to use another device to navigate to the verification URI to input credentials.\r\n   * Since the client cannot receive incoming requests, it polls the authorization server repeatedly\r\n   * until the end-user completes input of credentials.\r\n   */\n\n\n  _createClass(PublicClientApplication, [{\n    key: \"acquireTokenByDeviceCode\",\n    value: function () {\n      var _acquireTokenByDeviceCode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(request) {\n        var validRequest, serverTelemetryManager, deviceCodeConfig, deviceCodeClient;\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                this.logger.info(\"acquireTokenByDeviceCode called\", request.correlationId);\n                _context20.t0 = Object;\n                _context20.t1 = request;\n                _context20.next = 5;\n                return this.initializeBaseRequest(request);\n\n              case 5:\n                _context20.t2 = _context20.sent;\n                validRequest = _context20.t0.assign.call(_context20.t0, _context20.t1, _context20.t2);\n                serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByDeviceCode, validRequest.correlationId);\n                _context20.prev = 8;\n                _context20.next = 11;\n                return this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, undefined, request.azureCloudOptions);\n\n              case 11:\n                deviceCodeConfig = _context20.sent;\n                deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);\n                this.logger.verbose(\"Device code client created\", validRequest.correlationId);\n                return _context20.abrupt(\"return\", deviceCodeClient.acquireToken(validRequest));\n\n              case 17:\n                _context20.prev = 17;\n                _context20.t3 = _context20[\"catch\"](8);\n\n                if (_context20.t3 instanceof AuthError) {\n                  _context20.t3.setCorrelationId(validRequest.correlationId);\n                }\n\n                serverTelemetryManager.cacheFailedRequest(_context20.t3);\n                throw _context20.t3;\n\n              case 22:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this, [[8, 17]]);\n      }));\n\n      function acquireTokenByDeviceCode(_x30) {\n        return _acquireTokenByDeviceCode.apply(this, arguments);\n      }\n\n      return acquireTokenByDeviceCode;\n    }()\n    /**\r\n     * Acquires a token by requesting an Authorization code then exchanging it for a token.\r\n     */\n\n  }, {\n    key: \"acquireTokenInteractive\",\n    value: function () {\n      var _acquireTokenInteractive = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(request) {\n        var _yield$this$cryptoPro, verifier, challenge, openBrowser, successTemplate, errorTemplate, remainingProperties, loopbackClient, authCodeListener, redirectUri, validRequest, authCodeUrl, authCodeResponse, clientInfo, tokenRequest;\n\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.next = 2;\n                return this.cryptoProvider.generatePkceCodes();\n\n              case 2:\n                _yield$this$cryptoPro = _context21.sent;\n                verifier = _yield$this$cryptoPro.verifier;\n                challenge = _yield$this$cryptoPro.challenge;\n                openBrowser = request.openBrowser, successTemplate = request.successTemplate, errorTemplate = request.errorTemplate, remainingProperties = _objectWithoutProperties(request, _excluded);\n                loopbackClient = new LoopbackClient();\n                authCodeListener = loopbackClient.listenForAuthCode(successTemplate, errorTemplate);\n                redirectUri = loopbackClient.getRedirectUri();\n                validRequest = _objectSpread(_objectSpread({}, remainingProperties), {}, {\n                  scopes: request.scopes || [],\n                  redirectUri: redirectUri,\n                  responseMode: ResponseMode.QUERY,\n                  codeChallenge: challenge,\n                  codeChallengeMethod: CodeChallengeMethodValues.S256\n                });\n                _context21.next = 12;\n                return this.getAuthCodeUrl(validRequest);\n\n              case 12:\n                authCodeUrl = _context21.sent;\n                _context21.next = 15;\n                return openBrowser(authCodeUrl);\n\n              case 15:\n                _context21.next = 17;\n                return authCodeListener.finally(function () {\n                  loopbackClient.closeServer();\n                });\n\n              case 17:\n                authCodeResponse = _context21.sent;\n\n                if (!authCodeResponse.error) {\n                  _context21.next = 22;\n                  break;\n                }\n\n                throw new ServerError(authCodeResponse.error, authCodeResponse.error_description, authCodeResponse.suberror);\n\n              case 22:\n                if (authCodeResponse.code) {\n                  _context21.next = 24;\n                  break;\n                }\n\n                throw NodeAuthError.createNoAuthCodeInResponseError();\n\n              case 24:\n                clientInfo = authCodeResponse.client_info;\n                tokenRequest = {\n                  code: authCodeResponse.code,\n                  scopes: OIDC_DEFAULT_SCOPES,\n                  redirectUri: validRequest.redirectUri,\n                  codeVerifier: verifier,\n                  clientInfo: clientInfo || Constants$1.EMPTY_STRING\n                };\n                return _context21.abrupt(\"return\", this.acquireTokenByCode(tokenRequest));\n\n              case 27:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function acquireTokenInteractive(_x31) {\n        return _acquireTokenInteractive.apply(this, arguments);\n      }\n\n      return acquireTokenInteractive;\n    }()\n  }]);\n\n  return PublicClientApplication;\n}(ClientApplication);\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Client assertion of type jwt-bearer used in confidential client flows\r\n * @public\r\n */\n\n\nvar ClientAssertion = /*#__PURE__*/function () {\n  function ClientAssertion() {\n    _classCallCheck(this, ClientAssertion);\n  }\n\n  _createClass(ClientAssertion, [{\n    key: \"getJwt\",\n    value:\n    /**\r\n     * Update JWT for certificate based clientAssertion, if passed by the user, uses it as is\r\n     * @param cryptoProvider - library's crypto helper\r\n     * @param issuer - iss claim\r\n     * @param jwtAudience - aud claim\r\n     */\n    function getJwt(cryptoProvider, issuer, jwtAudience) {\n      // if assertion was created from certificate, check if jwt is expired and create new one.\n      if (this.privateKey && this.thumbprint) {\n        if (this.jwt && !this.isExpired() && issuer === this.issuer && jwtAudience === this.jwtAudience) {\n          return this.jwt;\n        }\n\n        return this.createJwt(cryptoProvider, issuer, jwtAudience);\n      }\n      /*\r\n       * if assertion was created by caller, then we just append it. It is up to the caller to\r\n       * ensure that it contains necessary claims and that it is not expired.\r\n       */\n\n\n      if (this.jwt) {\n        return this.jwt;\n      }\n\n      throw ClientAuthError.createInvalidAssertionError();\n    }\n    /**\r\n     * JWT format and required claims specified: https://tools.ietf.org/html/rfc7523#section-3\r\n     */\n\n  }, {\n    key: \"createJwt\",\n    value: function createJwt(cryptoProvider, issuer, jwtAudience) {\n      var _payload;\n\n      this.issuer = issuer;\n      this.jwtAudience = jwtAudience;\n      var issuedAt = TimeUtils.nowSeconds();\n      this.expirationTime = issuedAt + 600;\n      var header = {\n        alg: JwtConstants.RSA_256,\n        x5t: EncodingUtils.base64EncodeUrl(this.thumbprint, \"hex\")\n      };\n\n      if (this.publicCertificate) {\n        Object.assign(header, {\n          x5c: this.publicCertificate\n        });\n      }\n\n      var payload = (_payload = {}, _defineProperty(_payload, JwtConstants.AUDIENCE, this.jwtAudience), _defineProperty(_payload, JwtConstants.EXPIRATION_TIME, this.expirationTime), _defineProperty(_payload, JwtConstants.ISSUER, this.issuer), _defineProperty(_payload, JwtConstants.SUBJECT, this.issuer), _defineProperty(_payload, JwtConstants.NOT_BEFORE, issuedAt), _defineProperty(_payload, JwtConstants.JWT_ID, cryptoProvider.createNewGuid()), _payload);\n      this.jwt = sign(payload, this.privateKey, {\n        header: header\n      });\n      return this.jwt;\n    }\n    /**\r\n     * Utility API to check expiration\r\n     */\n\n  }, {\n    key: \"isExpired\",\n    value: function isExpired() {\n      return this.expirationTime < TimeUtils.nowSeconds();\n    }\n    /**\r\n     * Extracts the raw certs from a given certificate string and returns them in an array.\r\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\r\n     */\n\n  }], [{\n    key: \"fromAssertion\",\n    value:\n    /**\r\n     * Initialize the ClientAssertion class from the clientAssertion passed by the user\r\n     * @param assertion - refer https://tools.ietf.org/html/rfc7521\r\n     */\n    function fromAssertion(assertion) {\n      var clientAssertion = new ClientAssertion();\n      clientAssertion.jwt = assertion;\n      return clientAssertion;\n    }\n    /**\r\n     * Initialize the ClientAssertion class from the certificate passed by the user\r\n     * @param thumbprint - identifier of a certificate\r\n     * @param privateKey - secret key\r\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\r\n     */\n\n  }, {\n    key: \"fromCertificate\",\n    value: function fromCertificate(thumbprint, privateKey, publicCertificate) {\n      var clientAssertion = new ClientAssertion();\n      clientAssertion.privateKey = privateKey;\n      clientAssertion.thumbprint = thumbprint;\n\n      if (publicCertificate) {\n        clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);\n      }\n\n      return clientAssertion;\n    }\n  }, {\n    key: \"parseCertificate\",\n    value: function parseCertificate(publicCertificate) {\n      /**\r\n       * This is regex to identify the certs in a given certificate string.\r\n       * We want to look for the contents between the BEGIN and END certificate strings, without the associated newlines.\r\n       * The information in parens \"(.+?)\" is the capture group to represent the cert we want isolated.\r\n       * \".\" means any string character, \"+\" means match 1 or more times, and \"?\" means the shortest match.\r\n       * The \"g\" at the end of the regex means search the string globally, and the \"s\" enables the \".\" to match newlines.\r\n       */\n      var regexToFindCerts = /\\x2D\\x2D\\x2D\\x2D\\x2DBEGIN CERTIFICATE\\x2D\\x2D\\x2D\\x2D\\x2D\\r*\\n([\\s\\S]+?)\\r*\\n\\x2D\\x2D\\x2D\\x2D\\x2DEND CERTIFICATE\\x2D\\x2D\\x2D\\x2D\\x2D/g;\n      var certs = [];\n      var matches;\n\n      while ((matches = regexToFindCerts.exec(publicCertificate)) !== null) {\n        // matches[1] represents the first parens capture group in the regex.\n        certs.push(matches[1].replace(/\\r*\\n/g, Constants$1.EMPTY_STRING));\n      }\n\n      return certs;\n    }\n  }]);\n\n  return ClientAssertion;\n}();\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n *  This class is to be used to acquire tokens for confidential client applications (webApp, webAPI). Confidential client applications\r\n *  will configure application secrets, client certificates/assertions as applicable\r\n * @public\r\n */\n\n\nvar ConfidentialClientApplication = /*#__PURE__*/function (_ClientApplication2) {\n  _inherits(ConfidentialClientApplication, _ClientApplication2);\n\n  var _super4 = _createSuper(ConfidentialClientApplication);\n\n  /**\r\n   * Constructor for the ConfidentialClientApplication\r\n   *\r\n   * Required attributes in the Configuration object are:\r\n   * - clientID: the application ID of your application. You can obtain one by registering your application with our application registration portal\r\n   * - authority: the authority URL for your application.\r\n   * - client credential: Must set either client secret, certificate, or assertion for confidential clients. You can obtain a client secret from the application registration portal.\r\n   *\r\n   * In Azure AD, authority is a URL indicating of the form https://login.microsoftonline.com/\\{Enter_the_Tenant_Info_Here\\}.\r\n   * If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\r\n   * If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\r\n   * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\r\n   * To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\r\n   *\r\n   * In Azure B2C, authority is of the form https://\\{instance\\}/tfp/\\{tenant\\}/\\{policyName\\}/\r\n   * Full B2C functionality will be available in this library in future versions.\r\n   *\r\n   * @param Configuration - configuration object for the MSAL ConfidentialClientApplication instance\r\n   */\n  function ConfidentialClientApplication(configuration) {\n    var _this7;\n\n    _classCallCheck(this, ConfidentialClientApplication);\n\n    _this7 = _super4.call(this, configuration);\n\n    _this7.setClientCredential(_this7.config);\n\n    _this7.appTokenProvider = undefined;\n    return _this7;\n  }\n  /**\r\n   * This extensibility point only works for the client_credential flow, i.e. acquireTokenByClientCredential and\r\n   * is meant for Azure SDK to enhance Managed Identity support.\r\n   *\r\n   * @param IAppTokenProvider  - Extensibility interface, which allows the app developer to return a token from a custom source.\r\n   */\n\n\n  _createClass(ConfidentialClientApplication, [{\n    key: \"SetAppTokenProvider\",\n    value: function SetAppTokenProvider(provider) {\n      this.appTokenProvider = provider;\n    }\n    /**\r\n     * Acquires tokens from the authority for the application (not for an end user).\r\n     */\n\n  }, {\n    key: \"acquireTokenByClientCredential\",\n    value: function () {\n      var _acquireTokenByClientCredential = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(request) {\n        var clientAssertion, validRequest, azureRegionConfiguration, serverTelemetryManager, clientCredentialConfig, clientCredentialClient;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                this.logger.info(\"acquireTokenByClientCredential called\", request.correlationId); // If there is a client assertion present in the request, it overrides the one present in the client configuration\n\n                if (request.clientAssertion) {\n                  clientAssertion = {\n                    assertion: request.clientAssertion,\n                    assertionType: Constants.JWT_BEARER_ASSERTION_TYPE\n                  };\n                }\n\n                _context22.t0 = _objectSpread;\n                _context22.t1 = _objectSpread;\n                _context22.t2 = _objectSpread({}, request);\n                _context22.next = 7;\n                return this.initializeBaseRequest(request);\n\n              case 7:\n                _context22.t3 = _context22.sent;\n                _context22.t4 = (0, _context22.t1)(_context22.t2, _context22.t3);\n                _context22.t5 = {};\n                _context22.t6 = {\n                  clientAssertion: clientAssertion\n                };\n                validRequest = (0, _context22.t0)(_context22.t4, _context22.t5, _context22.t6);\n                azureRegionConfiguration = {\n                  azureRegion: validRequest.azureRegion,\n                  environmentRegion: process.env[REGION_ENVIRONMENT_VARIABLE]\n                };\n                serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByClientCredential, validRequest.correlationId, validRequest.skipCache);\n                _context22.prev = 14;\n                _context22.next = 17;\n                return this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, azureRegionConfiguration, request.azureCloudOptions);\n\n              case 17:\n                clientCredentialConfig = _context22.sent;\n                clientCredentialClient = new ClientCredentialClient(clientCredentialConfig, this.appTokenProvider);\n                this.logger.verbose(\"Client credential client created\", validRequest.correlationId);\n                return _context22.abrupt(\"return\", clientCredentialClient.acquireToken(validRequest));\n\n              case 23:\n                _context22.prev = 23;\n                _context22.t7 = _context22[\"catch\"](14);\n\n                if (_context22.t7 instanceof AuthError) {\n                  _context22.t7.setCorrelationId(validRequest.correlationId);\n                }\n\n                serverTelemetryManager.cacheFailedRequest(_context22.t7);\n                throw _context22.t7;\n\n              case 28:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this, [[14, 23]]);\n      }));\n\n      function acquireTokenByClientCredential(_x32) {\n        return _acquireTokenByClientCredential.apply(this, arguments);\n      }\n\n      return acquireTokenByClientCredential;\n    }()\n    /**\r\n     * Acquires tokens from the authority for the application.\r\n     *\r\n     * Used in scenarios where the current app is a middle-tier service which was called with a token\r\n     * representing an end user. The current app can use the token (oboAssertion) to request another\r\n     * token to access downstream web API, on behalf of that user.\r\n     *\r\n     * The current middle-tier app has no user interaction to obtain consent.\r\n     * See how to gain consent upfront for your middle-tier app from this article.\r\n     * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#gaining-consent-for-the-middle-tier-application\r\n     */\n\n  }, {\n    key: \"acquireTokenOnBehalfOf\",\n    value: function () {\n      var _acquireTokenOnBehalfOf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(request) {\n        var validRequest, onBehalfOfConfig, oboClient;\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                this.logger.info(\"acquireTokenOnBehalfOf called\", request.correlationId);\n                _context23.t0 = _objectSpread;\n                _context23.t1 = _objectSpread({}, request);\n                _context23.next = 5;\n                return this.initializeBaseRequest(request);\n\n              case 5:\n                _context23.t2 = _context23.sent;\n                validRequest = (0, _context23.t0)(_context23.t1, _context23.t2);\n                _context23.prev = 7;\n                _context23.next = 10;\n                return this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, undefined, undefined, request.azureCloudOptions);\n\n              case 10:\n                onBehalfOfConfig = _context23.sent;\n                oboClient = new OnBehalfOfClient(onBehalfOfConfig);\n                this.logger.verbose(\"On behalf of client created\", validRequest.correlationId);\n                return _context23.abrupt(\"return\", oboClient.acquireToken(validRequest));\n\n              case 16:\n                _context23.prev = 16;\n                _context23.t3 = _context23[\"catch\"](7);\n\n                if (_context23.t3 instanceof AuthError) {\n                  _context23.t3.setCorrelationId(validRequest.correlationId);\n                }\n\n                throw _context23.t3;\n\n              case 20:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this, [[7, 16]]);\n      }));\n\n      function acquireTokenOnBehalfOf(_x33) {\n        return _acquireTokenOnBehalfOf.apply(this, arguments);\n      }\n\n      return acquireTokenOnBehalfOf;\n    }()\n  }, {\n    key: \"setClientCredential\",\n    value: function setClientCredential(configuration) {\n      var clientSecretNotEmpty = !StringUtils.isEmpty(configuration.auth.clientSecret);\n      var clientAssertionNotEmpty = !StringUtils.isEmpty(configuration.auth.clientAssertion);\n      var certificate = configuration.auth.clientCertificate || {\n        thumbprint: Constants$1.EMPTY_STRING,\n        privateKey: Constants$1.EMPTY_STRING\n      };\n      var certificateNotEmpty = !StringUtils.isEmpty(certificate.thumbprint) || !StringUtils.isEmpty(certificate.privateKey);\n      /*\r\n       * If app developer configures this callback, they don't need a credential\r\n       * i.e. AzureSDK can get token from Managed Identity without a cert / secret\r\n       */\n\n      if (this.appTokenProvider) {\n        return;\n      } // Check that at most one credential is set on the application\n\n\n      if (clientSecretNotEmpty && clientAssertionNotEmpty || clientAssertionNotEmpty && certificateNotEmpty || clientSecretNotEmpty && certificateNotEmpty) {\n        throw ClientAuthError.createInvalidCredentialError();\n      }\n\n      if (configuration.auth.clientSecret) {\n        this.clientSecret = configuration.auth.clientSecret;\n        return;\n      }\n\n      if (configuration.auth.clientAssertion) {\n        this.clientAssertion = ClientAssertion.fromAssertion(configuration.auth.clientAssertion);\n        return;\n      }\n\n      if (!certificateNotEmpty) {\n        throw ClientAuthError.createInvalidCredentialError();\n      } else {\n        var _configuration$auth$c;\n\n        this.clientAssertion = ClientAssertion.fromCertificate(certificate.thumbprint, certificate.privateKey, (_configuration$auth$c = configuration.auth.clientCertificate) == null ? void 0 : _configuration$auth$c.x5c);\n      }\n    }\n  }]);\n\n  return ConfidentialClientApplication;\n}(ClientApplication);\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n\nvar DistributedCachePlugin = /*#__PURE__*/function () {\n  function DistributedCachePlugin(client, partitionManager) {\n    _classCallCheck(this, DistributedCachePlugin);\n\n    this.client = client;\n    this.partitionManager = partitionManager;\n  }\n\n  _createClass(DistributedCachePlugin, [{\n    key: \"beforeCacheAccess\",\n    value: function () {\n      var _beforeCacheAccess = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(cacheContext) {\n        var partitionKey, cacheData;\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                _context24.next = 2;\n                return this.partitionManager.getKey();\n\n              case 2:\n                partitionKey = _context24.sent;\n                _context24.next = 5;\n                return this.client.get(partitionKey);\n\n              case 5:\n                cacheData = _context24.sent;\n                cacheContext.tokenCache.deserialize(cacheData);\n\n              case 7:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      function beforeCacheAccess(_x34) {\n        return _beforeCacheAccess.apply(this, arguments);\n      }\n\n      return beforeCacheAccess;\n    }()\n  }, {\n    key: \"afterCacheAccess\",\n    value: function () {\n      var _afterCacheAccess = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(cacheContext) {\n        var kvStore, accountEntities, accountEntity, partitionKey;\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                if (!cacheContext.cacheHasChanged) {\n                  _context25.next = 10;\n                  break;\n                }\n\n                kvStore = cacheContext.tokenCache.getKVStore();\n                accountEntities = Object.values(kvStore).filter(function (value) {\n                  return AccountEntity.isAccountEntity(value);\n                });\n\n                if (!(accountEntities.length > 0)) {\n                  _context25.next = 10;\n                  break;\n                }\n\n                accountEntity = accountEntities[0];\n                _context25.next = 7;\n                return this.partitionManager.extractKey(accountEntity);\n\n              case 7:\n                partitionKey = _context25.sent;\n                _context25.next = 10;\n                return this.client.set(partitionKey, cacheContext.tokenCache.serialize());\n\n              case 10:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function afterCacheAccess(_x35) {\n        return _afterCacheAccess.apply(this, arguments);\n      }\n\n      return afterCacheAccess;\n    }()\n  }]);\n\n  return DistributedCachePlugin;\n}();\n\nexport { ClientApplication, ClientAssertion, ConfidentialClientApplication, CryptoProvider, DistributedCachePlugin, NodeStorage, PublicClientApplication, TokenCache, buildAppConfiguration, version }; //# sourceMappingURL=msal-node.esm.js.map","map":null,"metadata":{},"sourceType":"module"}